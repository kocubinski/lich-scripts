=begin

	bigshot.lic: the new optimus prime

	hunting script for hunting

	      author: Sheikh
	contributers: SpiffyJr, Tillmen
	        game: Gemstone
	        tags: hunting
	     version: 3.0

	changelog:
		3.0 (2015-05-30):
			stop trying to attack monsters that aren't in the room (wild guess, untested)
			bumped version up from 2.12052012 to 3.0, because 2.12052012 is a stupid version format
			added message to trust script

=end

# FIXME: Use new empty_hand(s)/fill_hand(s)
# FIXME: Is poaching?() redundant?
# FIXME: Instead of the head reiterating :ATTACK to tail every 15 seconds, have the tail loop upon :ATTACK until the room id changes

if $SAFE > 0
	echo "error: This script needs to be trusted to work. (;trust #{script.name})"
	exit
end

require 'drb'

# fixme: these constants and global variables could conflict with other scripts
BIGSHOT_VERSION ||= '3.0'
RALLY_TIME ||= 5
REST_INTERVAL ||= 30
$rest_reason = nil
$not_hunting_reason = nil
$bigshot_status = nil
$bigshot_should_rest = false

def spam
    def waitcastrt?
        return if Spell[515].active?
        if (XMLData.cast_roundtime_end.to_f - Time.now.to_f + XMLData.server_time_offset.to_f) > 0
            sleep((XMLData.cast_roundtime_end.to_f - Time.now.to_f + XMLData.server_time_offset.to_f).abs)
        end
    end

    def waitrt?
        if (XMLData.roundtime_end.to_f - Time.now.to_f + XMLData.server_time_offset.to_f) > 0
            sleep((XMLData.roundtime_end.to_f - Time.now.to_f + XMLData.server_time_offset.to_f).abs)
        end
    end
end

def unspam
    def waitcastrt?
        if (XMLData.cast_roundtime_end.to_f - Time.now.to_f + XMLData.server_time_offset.to_f) > 0
            sleep((XMLData.cast_roundtime_end.to_f - Time.now.to_f + XMLData.server_time_offset.to_f + "0.6".to_f).abs)
        end
    end

    def waitrt?
        if (XMLData.roundtime_end.to_f - Time.now.to_f + XMLData.server_time_offset.to_f) > 0
            sleep((XMLData.roundtime_end.to_f - Time.now.to_f + XMLData.server_time_offset.to_f + "0.6".to_f).abs)
        end
    end
end

before_dying { unspam() }
before_dying { $bigshot.gather_ammo }

class Event
    attr_accessor :type, :created_at, :room_id
    @@RECOGNIZED = [ :HUNTING_PREP_COMMANDS, :HUNTING_SCRIPTS_START, :CAST_SIGNS, :ATTACK,
        :HUNTING_SCRIPTS_STOP, :RESTING_SCRIPTS_START, :RESTING_PREP_COMMANDS, :DISPLAY_WATCH ]

    def initialize( type, time_stamp, room_id )
        raise "Event type not recognized" unless @@RECOGNIZED.include?(type)
        @type       = type
        @created_at = time_stamp
        @room_id    = room_id
    end

    def stale?
        if( Room.current.id != @room_id || Time.now.to_i - @created_at > 15 )
            return true
        else
            return false
        end
    end

    def type
        return @type
    end
end

class Group
    include DRbUndumped
    attr_accessor :leader, :members

    def initialize()
        @members = Hash.new
    end

    def set_leader(leader)
        @leader = leader
    end

    def add_member(member)
        @members[member.name()] = member
    end

    def size()
        return @members.size
    end

    def get_names
        return @members.keys + [@leader.name]
    end

    def room_id()
        return @leader.room_id()
    end

    def add_event(type)
        @members.each_pair { |k,v|
            begin
                v.add_event( type, Time.now.to_i, Room.current.id )
            rescue
                @leader.message("Error adding #{type.to_s} event to members stack: #{$!}")
                @leader.message($!.backtrace.join("\n"))
            end
        }
    end
 
    def add_leader_event(event)
        @leader.add_event( Event.new(event) ) unless @leader.event_stack.size > 5
    end

    def roundtime?()
        @members.each_pair { |k,v|
            begin
                return true if v.rt? > 0
            rescue
                @leader.message("Error polling member for RT. Removing!")
                @members.delete(k)
            end
        }
        return false
    end

    def should_hunt?()
        emergency = @leader.event_stack.size == 0 ? nil : @leader.event_stack.shift
        if(emergency)
            @leader.clear_events
            return false
        end

        @members.each_pair { |k,v|
            begin
                return false if !v.should_hunt?
            rescue
                @leader.message("Error polling member. Removing!")
                @members.delete(k)
            end
        }
		$bigshot_status = :hunting
        return true
    end

    def should_rest?()
        @members.each_pair { |k,v|
            begin
                return false if !v.should_rest?
            rescue
                @leader.message("Error polling member. Removing!")
                @members.delete(k)
            end
        }
        return true
    end
    
    def emergency_rest?()
        @members.each_pair { |k,v|
            begin
                return true if v.wounded?
            rescue
                @leader.message("Error polling member. Removing!")
                @members.delete(k)
            end
        }
        return false
    end
end

class Bigshot
    include DRbUndumped
    attr_accessor :BIRTH_TIME, :START_TIME, :STORED_TIMES, :FRIED, :OOM,
        :SIGNS, :TARGETS, :INVALID_TARGETS, :FLEE_COUNT, :ALWAYS_FLEE_FROM,
        :USE_WRACKING, :AMMO, :AMMO_CONTAINER, :HIDE_FOR_AMMO,
        :REST_TILL_EXP, :REST_TILL_MANA, :USE_HERBS, :DEAD_MAN_SWITCH,
        :RESTING_ROOM_ID, :RESTING_COMMANDS, :RESTING_SCRIPTS, :HUNTING_ROOM_ID,
        :HUNTING_BOUNDARIES, :HUNTING_SCRIPTS, :HUNTING_COMMANDS,
        :DISABLE_COMMANDS, :HUNTING_STANCE, :HUNTING_PREP_COMMANDS,
        :MONITOR_INTERACTION, :FLEE_CLOUDS, :WRACKING_SPIRIT,
        :REST_TILL_SPIRIT, :BOUNTY_MODE,
        :event_stack, :followers

    PRONE = /sleeping|webbed|stunned|kneeling|sitting|^lying|prone/

    def add_event( type, time_stamp, room_id )
        unless( @event_stack.size > 5 && type == :ATTACK )
            @event_stack.push( Event.new( type, time_stamp, room_id ) )
        end
    end

    def grab_event()
        @event_stack.shift()
    end

    def clear_events()
        @event_stack.clear
    end

    def initialize(bounty_mode=nil)
		$bigshot = self
        if bounty_mode
            @BOUNTY_MODE = true
        end
		
        UserVars.op ||= Hash.new
        CharSettings['targetable']   ||= Array.new
        CharSettings['untargetable'] ||= Array.new
        @BIRTH_TIME   = Time.now.to_i
        @START_TIME   = 1
        @STORED_TIMES = Array.new

        @followers = nil
        @event_stack = Array.new

        load_settings()
        dead_man_switch()

        # this is mainly for azbounty:
        before_dying {
            @HUNTING_SCRIPTS.each { |i|
                echo "Cleaning up hunting scripts: #{i}."
                stop_script(i) if running?(i)
            }
        }
                
    end
	
	def load_settings()
		set_value_required( 'hunting_commands',     'split_xx' )
        set_value_required( 'fried',                'to_i'     )
        set_value_required( 'oom',                  'to_i'     )
        set_value_required( 'rest_till_mana',       'to_i'     )
        set_value_required( 'rest_till_exp',        'to_i'     )

        set_value( 'hunting_room_id',      'to_i',  4 )
        set_value( 'resting_room_id',      'to_i',  4 )
        set_value( 'hunting_boundaries',   'split',    Array.new )
        set_value( 'hunting_commands_b',   'split_xx', Array.new )
        set_value( 'hunting_commands_c',   'split_xx', Array.new )
        set_value( 'disable_commands',     'split_xx', Array.new )
		
        set_value( 'targets',          'targets',         nil       )
        set_value( 'dead_man_switch',     '',             false     )
        set_value( 'monitor_interaction', '',             false     )
        set_value( 'depart_switch',       '',             false     )
        set_value( 'encumbered',       'to_i',            200       )
        set_value( 'signs',            'split',           Array.new )
        set_value( 'spam',             '',                true      )
        set_value( 'flee_count',       'to_i',            10        )
        set_value( 'wracking_spirit',  'to_i',            0         )
        set_value( 'invalid_targets',  'split',           Array.new )
        set_value( 'always_flee_from', 'split',           Array.new )
        set_value( 'flee_clouds',      '',                false     )
        set_value( 'use_wracking',     '',                false     )
        set_value( 'lone_targets_only', '',               false     )
        set_value( 'rest_till_spirit', 'to_i',            0         )
        set_value( 'ammo',             '',                nil       )
        set_value( 'ammo_container',   '',                nil       )
        set_value( 'fresh_wand_container',   '',          nil       )
        set_value( 'dead_wand_container',    '',          nil       )
        set_value( 'wand',                   '',          nil       )
        set_value( 'wand_if_oom',            '',          false     )
        set_value( 'hide_for_ammo',    '',                nil       )
        set_value( 'wounded_eval',     '',                nil       )
        set_value( 'resting_scripts',  'split',           Array.new )
        set_value( 'hunting_scripts',  'split',           Array.new )
        set_value( 'loot_script',      '',                nil       )
        set_value( 'hunting_stance',   '',                'defensive')
        set_value( 'resting_commands',           'split_xx',      Array.new )
        set_value( 'hunting_prep_commands',      'split_xx',      Array.new )
	end

    def clean_value( clean, value )
        if( clean == 'to_i' )
            return value.to_i
        elsif( clean == 'split' )
            return value.split(/,\s*/)
        elsif( clean == 'split_xx' )
            cleaned = Array.new
            value.split(/,\s*/).each { |i|
                rep = 1
                cmd = ''
                if( i =~ /(.*)\(x(\d+)\)$/ )
                    rep = $2.to_i
                    cmd = $1
                elsif( i =~ /(.*)\(xx\)/ )
                    rep = 5
                    cmd = $1
                else
                    cmd = i
                end
                and_tokens = cmd.split(/\sand\s/)
                cmd = and_tokens.size == 1 ? and_tokens[0] : and_tokens
                rep.times do cleaned.push(cmd) end
            }
            return cleaned
        elsif( clean == 'targets' )
            targets = Hash.new
            tokens = value.split(/,/)
            tokens.each do |i|
                if( i =~ /(.*)\(([a|b|c|A|B|C])\)/ )
                    targets[$1.downcase.strip] = $2.downcase.strip
                else
                    targets[i.downcase.strip] = 'a'
                end
            end
            return targets
        else
            return value
        end
    end

    def set_value( key, clean, default )
        if( !UserVars.op[key].nil? && UserVars.op[key] !~ /^\s*$/ )
            cleaned = clean_value( clean, UserVars.op[key] )
            instance_variable_set( "@#{key.upcase}", cleaned )
        else
            instance_variable_set( "@#{key.upcase}", default )
        end
    end

    def set_value_required( key, clean )
        if( !UserVars.op[key].nil? && UserVars.op[key] !~ /^\s*$/ )
            set_value( key, clean, nil )
        else
            message("ERROR: Missing required setting: #{key}")
            message("(fried? is percenthealth and oom is percentmana)")
            Script.self.kill
        end
    end

    def cmd( command, npc = nil, stance_dance = true )
        command = command.dup

        if( command.class.to_s == 'Array' )
            stance_dance = false if command.any? { |j| j =~ /stance/ }
            command.each do |i|
                cmd( i, npc, stance_dance )
            end
            return
        end

        # check mana/stamina
        if( command =~ /(.*)\(([s|m])(\d+)\)$/ )
            if( $2 == 's' )
                return if !checkstamina($3.to_i)
            elsif( $2 == 'm' )
                return if !checkmana($3.to_i)
            end
            command = $1
        end
        
        if( command =~ /force\s+(.*)\s+(?:till|until)\s+(\d+)/ )            
            cmd_force( $1, $2.to_i, npc )
            return
        end
        
        # sub id
        command.gsub!( /target/, "##{npc.id}" ) if !npc.nil?
        
        # waitrt/waitcastrt
        unless( command =~ /^nudgeweapons?/ )
            waitrt?
            waitcastrt? if command =~ /^\d+|incant/
        end

        # change_stance
        stand()
        unless( command =~ /^(?:\d+|wait|sleep|wand|berserk|script|hide|nudgeweapon)/ )
            change_stance(@HUNTING_STANCE) if stance_dance
        end

        return if npc && !valid_target?(npc)

        if( command =~ /^(\d+)(.*)$/ )
            cmd_spell( $1.to_i, $2.strip, npc )
		elsif( command =~ /^throw/i )
			cmd_throw( npc )
		elsif( command =~ /^k?weed/i )
			cmd_weed( command, npc )
        elsif( command =~ /^wand\s+(.*)/i )
            cmd_wand(npc)
        elsif( command =~ /^hide/i )
            cmd_hide()
        elsif( command =~ /^mstrike/i )
            cmd_mstrike( command, npc )
        elsif( command =~ /^fire/i )
            cmd_ranged(npc)
        elsif( command =~ /^berserk/i )
            cmd_berserk()
        elsif( command =~ /^script\s+(.*?)(\s|$)(.*)/i )
            cmd_run_script( $1, $3 )
        elsif( command =~ /^sleep\s+(\d+)/i )
            cmd_sleep( $1, npc )
        elsif( command =~ /^stance\s+(.*)/i )
            change_stance($1)
        elsif( command =~ /^wait\s+(\d+)/i )
            wait_for_swing( $1.to_i, npc )
        elsif( command =~ /^nudgeweapons?\s*/i )
            cmd_nudge_weapons
        else
            return if command =~ /1030/ && checkmana < 10
            bs_put command
        end
    end
	
	def cmd_throw( npc )
		unless npc.status == 'lying down'
			empty_hands
			dothistimeout "throw ##{npc.id}", 1, /^You attempt to throw a .*\!$/
			waitrt?
			fill_hands
		end
	end
    
    def cmd_force( force_this, goal, npc )
        start = Time.now
        loop {
            cmd( force_this, npc )
            buffer = reget(20)
            buffer.each_with_index { |line, i|
                if( line =~ /^You.*(#{checknpcs.join('|')})(\.|!)|^You feint (high|low|(to the (left|right)))/ )
                    if buffer[i + 1] && buffer[i + 1] =~ /== \+(\d+)/
                        return if $1.to_i >= goal # spell/swing
                    elsif buffer[i - 1] && buffer[i - 1] =~ /^\[Roll result: (\d+)/
                        return if $1.to_i >= goal # cman
                    elsif buffer[i + 1] =~ /^As you focus on your magic, your vision swims with a swirling haze of crimson/
                        return
                    end
                elsif( line =~ /^You do not have enough stamina to attempt this maneuver\./ )
                    return
                elsif( line =~ /^Your magic fizzles ineffectually\./ )
                    return
                end
            }
            if ( force_this =~ /^(\d+) / && !Spell[$1.to_i].affordable? )
                message("Force ran out of mana. Giving up."); return;
            end
            return if GameObj.npcs.size.nil? || GameObj.npcs.size == 0
            return if should_flee?
            return if should_rest?
            return if npc.status =~ /dead|gone/
            return if ( Time.now - start ) > 30
        }
    end
	
	def cmd_weed( command, target )
		return if target.status =~ /dead|gone/
		return if GameObj.loot.find { |loot| loot.name =~ /vine/ }
		return unless Spell[610].known? and Spell[610].affordable?
		
		waitcastrt?
		change_stance('offensive') if command == 'kweed'
		Spell[610].cast("##{target.id}")
		change_stance('guarded') if command == 'kweed'
		waitcastrt?
	end

    def cmd_spell( id, target_id, target )
        if ( checkprep != "None" and checkprep != Spell[id].name )
            fput 'release'
        end

        return if id == 506 and Spell[506].active?
        return if id == 9605 and Spell[9606].active? # surge cooldown
		return if target.status =~ /dead|gone/
        unless( Spell[id].affordable? )
            if(@WAND_IF_OOM)
                cmd_wand(target); return;
            end
            if(@USE_WRACKING)
                wrack()
            end
        end
		
		if ( !Spell[id].affordable? and id != 9605 and id != 506 )
			$bigshot_should_rest = true
			$rest_reason = "out of mana"
		end
        waitcastrt?
        Spell[id].cast(target_id)
    end

    def cmd_wand(target)
        if(@FRESH_WAND_CONTAINER)
            hands = GameObj.right_hand.name.to_s + GameObj.left_hand.name.to_s
            wand  = ( @WAND && @WAND !~ /^\s*$/ ) ? @WAND : 'wand'
            until( (GameObj.right_hand.name.to_s + GameObj.left_hand.name.to_s) =~ /#{wand}/i )
                result = dothistimeout( "get #{wand} from my #{@FRESH_WAND_CONTAINER}", 3, /You remove|You slip|Get what/ )
                if( result =~ /Get what/ )
                    message("ERROR: Couldn't find fresh wand. Gonna rest."); $bigshot_should_rest = true; return;
                elsif(result.nil?)
                    message("ERROR: Timed out looking for wand."); return;
                end
            end

            change_stance('offensive')
            result = dothistimeout( "wave my wand at ##{target.id}", 2, /d100|You hurl|is already dead|You do not see that here|You are in no condition|I could not find|Wait/ )
            change_stance('defensive')
            
            if( result =~ /You are in no condition/ )
                message("ERROR: Wounded. Gonna rest."); $bigshot_should_rest = true; return;
            elsif(result.nil?)
                if(@DEAD_WAND_CONTAINER)
                    bs_put "put my wand in my #{@DEAD_WAND_CONTAINER}"
                else
                    bs_put "drop my wand"
                end
            end
        else
            message("ERROR: Wand command called but fresh wand container not defined.")
        end
    end

    def cmd_hide()
        tries = 0
        until(hiding?)
            break if tries > 3 || should_flee?
            change_stance('defensive')
            bs_put 'hide'; tries += 1;
        end
    end

    def cmd_mstrike( command, target )
        if( !Spell[9005].active? && Skills.multiopponentcombat >= 30 && GameObj.npcs.all? { |i| i.noun !~ /nest/i } )
            if( GameObj.npcs.size > 1 and target.nil? )
                bs_put "mstrike"
            else
                bs_put "mstrike ##{target.id}"
            end
        else
            bs_put "kill ##{target.id}"
        end
    end

    def cmd_ranged(npc)
        waitrt?

        result = dothistimeout "get 1 my #{@AMMO.sub(/s$/, '')}", 2, /You remove|Get what\?|You already/
		if( result =~ /Get what\?/ )
			$bigshot_should_rest = true
            $rest_reason = "Out of ammo"
			return
		end
		
        result = dothistimeout(
            "fire ##{npc.id}",
            2,
            /You fire|You cannot|Could not find|seconds|Get what?/
        )
        if( result =~ /^Could not find/ )
			#$bigshot_should_rest = true
            #$rest_reason = "Out of ammo"
			gather_ammo
		elsif( result =~ /You cannot fire/ )
			unless GameObj.right_hand.id.nil?
				line = dothistimeout "stow ##{GameObj.right_hand.id}", 3, /put|closed/
				if line =~ /closed/
					fput "open my #{@AMMO_CONTAINER}"
					fput "put ##{GameObj.right_hand.id} in my ##{@AMMO_CONTAINER}"
				end
			end
		elsif( result =~ /but it has no effect/ )
            $bigshot_should_rest = true
            $rest_reason = "Ammo had no effect (need blessed or magical)"
		elsif ( result == false )
			$bigshot_should_rest = true
			$rest_reason = "Unknown result from fire routine: #{result}"
        end
    end

    def cmd_berserk()
        if( checkstamina(20) )
            put 'stance def'
            until( get =~ /^Everything around you turns red|^You scream/ )
                bs_put 'berserk'
            end
            until( get =~ /^The redness fades from the world/ )
                break if checkmind(7)
            end
        else
            bs_put 'target random'; bs_put 'kill';
        end
    end

    def cmd_run_script( name, args )
        if( args == nil || args =~ /^\s*$/ )
            run_script( name, true )
        else
            args = args.split(/ /)
            run_script( name, true, args )
        end
    end

    def cmd_sleep( time, npc )
        change_stance('defensive')
        time.to_i.times do
            sleep 1
            break if should_rest?
            break if npc && npc.status =~ /dead|gone/
        end
    end
    
    def cmd_nudge_weapons()
        return if checkpaths.size == 0

        GameObj.loot.each { |i|
            next unless i.noun =~ /axe|scythe|pitchfork|falchion|sword|lance|sword|dagger|estoc|falchion|handaxe|katana|katar|gauche|rapier|scimitar|whip-blade|cudgel|crowbill|whip|mace|star|hammer|claidhmore|flail|flamberge|maul|pick|staff|mattock/
            change_stance('defensive')
            
            sheathed = false
            unless( righthand.nil? || lefthand.nil? )
                sheathed = true
                fput 'sheath'
                unless( righthand.nil? || lefthand.nil? )
                    message("Unable to empty hands via sheath.")
                    return
                end
            end
        
            dirs = checkpaths
            dir  = checkpaths.shift
            fput "get ##{i.id}"
            put dir
            put "drop ##{i.id}"
            fput reverse_direction(dir)
            fput "gird" if sheathed
        }
    end

    def message(text)
        string = ''
        if $fake_stormfront then string.concat("\034GSL\r\n ") else string.concat("<pushBold\/>") end
        if( text.index('\n') )
            text.split('\n').each { |line| string.concat("| #{line}") }
        else
            string.concat('| ' + text)
        end
        if $fake_stormfront then string.concat("\034GSM\r\n ") else string.concat("<popBold\/>") end
        puts string
    end

    def dead_man_switch()
        if @DEAD_MAN_SWITCH
            Thread.new {
                while( running?('bigshot') )
                    if( dead? ||  percenthealth < 40 )
                        echo 'AUTOBOT ALERT: Your character is in trouble!'
                        fput 'quit'
                    end
                    sleep 2
                end
            };
        elsif @DEPART_SWITCH
            start_exec_script( <<-EOF
                while( running?('bigshot') );
                    if(dead?);
                        stop_script('bigshot');
                        fput 'depart'; fput 'depart';
                        fput 'depart confirm'; fput 'depart confirm';
                        start_script('waggle');
                        15.times { sleep 60; fput info; };
                        sleep 1 until percentspirit == 100 && !running?('waggle');
                        start_script( 'bigshot', ['solo'] );
                        Script.self.kill;
                    end;
                    sleep 5;
                end;
                EOF
            );
        else
            Thread.new {
                loop { Script.self.kill if dead?; sleep 5; }
            }
        end
    end

    def keep_awake()
        Thread.new {
            while( running?('bigshot') )
                sleep 150; put 'look';
            end
        }
    end 

    def monitor_interaction()
        if @MONITOR_INTERACTION
            start_exec_script( <<-eos
                def show_window(line);
                    window_title = Char.name + ':' + line;
                    Gtk.queue {
                        $myWindow = Gtk::Window.new;
                        $myWindow.title = "Autobot Alert!";
                        $myWindow.set_size_request(450, 25);
                        label = Gtk::Label.new window_title;
                        $myWindow.add(label);
                        $myWindow.show_all;
                    };
                end;
                while(line = get);
                    break unless running?('bigshot');
                    if(line =~ /SEND|POLICY|[Rr](\s)*[Ee](\s)*[Pp](\s)*[Oo](\s)*[Rr](\s)*[Tt]|peaking to you|unresponsive|taps you|nods to you|lease respond|not in control|character|violation|lease speak|peak out loud|Y U SHOU D|whispers,|speaking to you|smiles at you|waves to you|grins at you|hugs you|takes hold your hand|grabs your hand|clasps your hand|trying to drag you/);
                        unless(line =~ /LNet/);
                            show_window(line);
                            echo "AUTOBOT ALERT: " + line;
                        end;
                    end;
                end;
            eos
            )
        end
    end

    def wrack()
        if Spell[9918].known? and not Spell[9012].active?
            Spell[9918].cast if checkspirit >= @WRACKING_SPIRIT
        elsif Spell[9718].known?
            ( checkstamina / 50 ).times { Spell[9718].cast }
        end
    end

    def change_stance( new_stance, force = true )
        #return unless new_stance =~ /off/ # pookahs/bog
        return if Spell[1617].active? || Spell[216].active? || dead?

        if( stance() =~ /#{new_stance}/ )
            return
        elsif( checkcastrt() > 0 && new_stance =~ /def/ )
            return if stance() == 'guarded'
        end

        if(force)
            result = dothistimeout( "stance #{new_stance}", 3, /You are now in an?|Cast Round Time in effect|You are unable to change/ )
        else
            put "stance #{new_stance}"
        end
    end

    def wait_for_swing( seconds, target = nil )
        status_tags
        start = Time.now
        swung = false
        while(1)
            change_stance( 'defensive', false ) unless target && target.status =~ PRONE
            stand()
            
            pcs = checkpcs ? ' you(\.|!|r? )|' + checkpcs.join('|') : 'you(\.|!|r? )'
            break if clear.any? { |line| line =~ /#{target.id}.*(#{pcs})/ && line !~ /^<style id=""\/><style id="roomDesc"\/>|<component id='room objs'>|<compDef id='room objs'>/ }
            break if GameObj.npcs.size.nil? || GameObj.npcs.size == 0
            break if should_flee?
            break if target && target.status =~ PRONE
            break if ( Time.now - start ) > seconds
            sleep 0.50
        end
        status_tags
    end

    def croak(message)
        message(message);
        croak_scripts( ['bigshot'] )
    end

    def run_script( name, pause_bigshot = false, args = [] )
        if Script.running.find { |s| s.name.downcase == name.downcase }.paused or running? name
            stop_script name
            wait_while { running? name }
        end

        start_script name, args 
        if pause_bigshot
            wait_until { !running? name }
        end
    end

    def run_scripts( scripts, pause_bigshot = false )
        scripts.each do |i|
            tokens = i.split(/\s+/)
            if( tokens.size > 1 )
                run_script( tokens[0], pause_bigshot, tokens[1..-1] )
            else
                run_script( tokens[0], pause_bigshot )
            end
        end
    end

    def croak_script(name)
        kill_script(name) if running?(name)
    end

    def croak_scripts(scripts)
        scripts.each { |i| croak_script(i) }
    end

    def stand()
        until(standing?)
            change_stance('defensive')
            bs_put 'stand'
        end
    end

    def lead( my_group = nil )
        monitor_interaction()
        @followers = my_group || Group.new()

        if(should_rest?)
            rest()
        else
            hunt()
        end
    end

    def find_routine(target)
        if( !solo? && fried? )
            return @DISABLE_COMMANDS
        else
			key = @TARGETS.keys.find { |k| target.name =~ /^#{k}$/ or target.noun =~ /^#{k}$/ }
			if key.nil?
				routine_letter = 'a'
			else
				routine_letter = @TARGETS[key]
			end
			
			if routine_letter == 'c'
				return @HUNTING_COMMANDS_C unless @HUNTING_COMMANDS_C.size == 0
			elsif routine_letter == 'b'
				return @HUNTING_COMMANDS_B unless @HUNTING_COMMANDS_B.size == 0
			end
			
			return @HUNTING_COMMANDS
        end
    end

    def solo?
        # tails wont have followers
        if( @followers && @followers.size == 0 )
            return true
        else
            return false
        end
    end

    def leading?
        return !following?
    end
    
    def following?
        return @followers.nil?
    end
    
    def pre_hunt()
        # prep/go
        @followers.add_event(:HUNTING_PREP_COMMANDS)
        @HUNTING_PREP_COMMANDS.each { |i| fput(i) }

        @followers.add_event(:CAST_SIGNS)
        cast_signs()

        @followers.add_event(:HUNTING_SCRIPTS_START)
        run_scripts( @HUNTING_SCRIPTS, false )

        goto(@HUNTING_ROOM_ID)
        if( !solo? && @followers.get_names.any? { |i| !checkpcs.include?(i) } )
            @followers.add_event(:CAST_SIGNS) # trigger rubber band
            sleep 10 # wait for followers
        end
    end
    
    def do_hunt()
        spam() if UserVars.op['spam']
        
        start_watch()
        message('Bigshot hunting')

        # loop
        target = nil
        just_arrived = true
        last_attack = 0
        loop {
            while( (target = find_target(target, just_arrived)) && !should_rest? )
                if( (Time.now.to_i - last_attack > 15) || just_arrived )
                    @followers.add_event(:ATTACK)
                    last_attack = Time.now.to_i
                end
                attack(target)
                just_arrived = false
                loot()
            end
            gather_ammo()

            if(should_rest?)
                break
            else
                prepare_for_movement()
                target = bs_wander()
				sleep 1
                just_arrived = true
            end
        }

        unspam()
    end

    # this is a leader method
    def hunt()
        pre_hunt()
        do_hunt()
        rest()
    end

    # this is a leader method
    def rest()
        message("Bigshot resting: #{$rest_reason}")
        $bigshot_should_rest = nil
        if @BOUNTY_MODE # bounty script should take over from here
          echo "Bounty mode. Killing self. Reason: #{$rest_reason}"
          Script.self.kill
        end
          
        stop_watch()

        # prep/go
        goto(@RESTING_ROOM_ID)
        @followers.add_event(:DISPLAY_WATCH)

        @followers.add_event(:HUNTING_SCRIPTS_STOP)
        croak_scripts(@HUNTING_SCRIPTS)
        
        @followers.add_event(:RESTING_PREP_COMMANDS)
        @RESTING_COMMANDS.each { |i| fput(i) }

        @followers.add_event(:RESTING_SCRIPTS_START)
        run_scripts( @RESTING_SCRIPTS, true )

        # loop
        until(should_hunt?)
            fput 'exp'
            display_watch_current()
            display_watch_average()
            display_watch_total()
            message( "Bigshot last rested because: #{$rest_reason}" ) if $rest_reason
            message( "Bigshot isn't hunting because: #{$not_hunting_reason}" ) if $not_hunting_reason
            sleep REST_INTERVAL
        end

        hunt()
    end

    def attack(target)
        commands = find_routine(target)

        commands.each do |i|
            return unless valid_target?(target)
            return if wounded? || $bigshot_should_rest
            stand()
            cast_signs()
            
            cmd( i, target )
        end
        sleep 1 if commands.size == 0
    end

    def goto(id)
        prepare_for_movement()
        until( Room.current.id == id )
            run_script( 'go2', true, [ id, '_disable_confirm_' ] )
        end
    end

    def start_watch()
        @START_TIME = Time.now.to_i
    end

    def stop_watch()
        if( @START_TIME > 100 )
            @STORED_TIMES.push( Time.now.to_i - @START_TIME )
        end
        @START_TIME = 0
    end

    def display_watch_current()
        if( @STORED_TIMES.size > 0 )
            seconds = @STORED_TIMES[-1]
            message( sprintf( "Bigshot: Last Hunt: %d min. %0.2f secs.",
                seconds / 60, seconds % 60 ) )
        end
    end

    def display_watch_average()
        average = 0
        if( @STORED_TIMES.size == 1 )
            average = @STORED_TIMES[0]
        elsif( @STORED_TIMES.size > 1 )
            @STORED_TIMES.each { |i| average += i }
            average /= @STORED_TIMES.size
        else
            return
        end
        message( sprintf( "Bigshot: Average Hunt: %d min. %0.2f secs.",
            average / 60, average % 60 ) )
    end

    def display_watch_total()
        total = Time.now.to_i - @BIRTH_TIME
        message( sprintf( "Bigshot: Total Time Running: %d min.  %0.2f secs.",
            total / 60, total % 60 ) )
    end

    def room_id()
        return Room.current.id()
    end

    def name()
        return Char.name
    end

    def poaching?()
        if(leading?)
            checkpcs.each { |i| return true unless @followers.get_names.include?(i) }
            return false
        else
            return false
        end
    end

    def should_flee?( just_entered = false )
        GameObj.loot.each { |i| return true if i.noun == 'cloud' } if @FLEE_CLOUDS
        return true if GameObj.npcs.any?  { |i| @ALWAYS_FLEE_FROM.include?(i.noun) }
        return true if checkpcs.any?      { |i| @ALWAYS_FLEE_FROM.include?(i) }
        return true if !leading? && checkpcs.empty?

        npcs = GameObj.npcs.find_all { |i| i.status !~ /dead|gone/ }
		npcs.delete_if { |npc| (@INVALID_TARGETS.include?(npc.name) or @INVALID_TARGETS.include?(npc.noun)) }
		
		flee_count = (just_entered && @LONE_TARGETS_ONLY) ? 1 : @FLEE_COUNT
		if npcs.size > flee_count
			return true
		end
    end

    def valid_target?( target, just_entered = false )
        return false if target == nil || target == false
        return false if should_flee?(just_entered)
        return false if just_entered && poaching?
        return false if target.noun =~ /child|traveller|scribe|merchant|dignitary|official|magistrate/i
        
        if( !CharSettings['targetable'].include?(target.noun) && !CharSettings['untargetable'].include?(target.name) )
            result = dothistimeout( "target ##{target.id}", 3, /^You are now targeting|^You can't target/ )
            if( result =~ /^You are now targeting/ )
                CharSettings['targetable'].push(target.noun)
            elsif( result =~ /^You can't target/ )
                CharSettings['untargetable'].push(target.noun)
            end
        end
        return false if CharSettings['untargetable'].include?(target.noun)
        if (target.status !~ /dead|gone/) and GameObj.npcs.any? { |n| n.id == target.id } and (@TARGETS.nil? or @TARGETS.keys.any? { |i| target.name =~ /^#{i}$/i or target.noun =~ /^#{i}$/i })
            return true
        else
            return false
        end
    end

    def sort_npcs()
		targets = @TARGETS
			
		npcs = GameObj.npcs
		sorted = Array.new
		
		targets.keys.each { |target| sorted += npcs.find_all { |npc| (npc.name =~ /^#{target}$/i or npc.noun =~ /^#{target}$/i) }.to_a }
		sorted.flatten
    end
	
    def find_target( target, just_entered = false )
        return target if valid_target?(target, just_entered)
		
        sort_npcs.each { |i| return i if valid_target?( i, just_entered ) }
        
        # nothing valid
        return nil
    end

    def rt?()
        return checkrt()
    end

    def fried?()
        if( percentmind() >= @FRIED )
            return true
        end
        return false
    end

    def oom?()
        if( percentmana() < @OOM )
            return true
        end
        return false
    end

    def ammo_on_ground(ammo)
        return GameObj.loot.find { |i| i.name =~ /^#{ammo}$/i or i.noun =~ /#{ammo}s?/i }
    end

    def gather_ammo()
        ammo = @AMMO; container = @AMMO_CONTAINER; hide = @HIDE_FOR_AMMO;
        return if ammo == nil || wounded?
 
        while( ammo_on_ground(ammo) )
            change_stance('defensive')
			
			unless GameObj.right_hand.id.nil?
				line = dothistimeout "stow ##{GameObj.right_hand.id}", 3, /put|closed/
				if line =~ /closed/
					fput "open my #{@AMMO_CONTAINER}"
					fput "put ##{GameObj.right_hand.id} in my ##{@AMMO_CONTAINER}"
				end
			end
			
            result = dothistimeout(
                "gather #{ammo}",
                2,
                /^You gather|^You pick up|^I could not|^What were you|^You may only|reach|on the ground/
            )
			
			if( result =~ /on the ground/)
				result = dothistimeout "get arrows", 3, /^You gather|^You pick up|^I could not|^What were you|^You may only|reach|on the ground/
			end

            if( result =~ /^You gather|^You pick up/ )
                dothistimeout(
                    "put my #{ammo} in my #{ammo} in my #{container}",
                    2,
                    /^I could not find|^You can't seem to|^You add|^You bundle|You cannot bundle/
                )
                bs_put "put my #{ammo} in my #{container}" if righthand?
			elsif( result =~ /You may only/ )
				return
            elsif( result == false || result =~ /^I could not find|^What were you/ )
                return
            elsif( result =~ /reach/ )
				bs_put 'hide' if hide and not hidden?
				sleep 4
            end
        end
    end

    def wounded?()
        if(@WOUNDED_EVAL)
            return eval @WOUNDED_EVAL
        else
            return false
        end
    end

    def should_hunt?()
        if(wounded?)
            $not_hunting_reason = 'wounded.'
            return false
        end
        if( percentencumbrance >= @ENCUMBERED )
            $not_hunting_reason = 'encumbered.'
            return false
        end
        if( @RESTING_SCRIPTS.any? { |i| running?(i) } )
            $not_hunting_reason = 'resting scripts still running.'
            return false
        end

        followers_should = (leading? && !solo?) ? @followers.should_hunt? : true
        if(followers_should)
            if( percentmind() > @REST_TILL_EXP )
                $not_hunting_reason = 'mind still above threshold.'
                return false
            elsif( percentmana() < @REST_TILL_MANA )
                $not_hunting_reason = 'mana still below threshold.'
                return false
            elsif( checkspirit() < @REST_TILL_SPIRIT )
                $not_hunting_reason = 'spirit still below threshold.'
                return false
            end
        else
            $not_hunting_reason = 'followers still need rest.'
            return false
        end
		$bigshot_status = :hunting
        return true
    end

    def should_rest?()
        if($bigshot_should_rest)
            $rest_reason = "$bigshot_should_rest was set to true." unless $rest_reason
			$bigshot_status = :resting
            return true
        elsif(wounded?)
            $rest_reason = "wounded."
			$bigshot_status = :resting
            return true
        elsif( percentencumbrance >= @ENCUMBERED )
            $rest_reason = "encumbered."
			$bigshot_status = :resting
            return true
        elsif( leading? && !solo? && @followers.emergency_rest? )
            $rest_reason = "emergency rest."
			$bigshot_status = :resting
            return true
        end

        followers_fried = (leading? && !solo?) ? @followers.should_rest? : true

        if(followers_fried)
            if(fried?)
                $rest_reason = "fried."
				$bigshot_status = :resting
                return true
            elsif(oom?)
                wrack() if @USE_WRACKING
                return false if !oom?
                
                $rest_reason = "out of mana."
				$bigshot_status = :resting
                return true
            end
        end
        
        $rest_reason = "none."
        return false
    end

    def cast_signs(single_cast = false)
        @SIGNS.each do |i|
            i = i.to_i
			next if [ 9903,9904,9905,9906,9907,9908,9909,9910,9912,9913,9914,9918 ].include?(i) and Spell[9012].active?
            next if i == 9918
            next if i == 9603 && Spell[9604].active?
            next if i == 9605 && Spell[9606].active?
            sign = Spell[i]
            next unless sign.known?

            # wrack?
            mana_cost = sign.mana_cost > 1 ? sign.mana_cost : 0 # Many erroneously return 1
            wrack() if !sign.affordable? and mana_cost > checkmana and @USE_WRACKING

            if( !sign.active? && sign.affordable? )
                if( i  == 9805 )
                    2.times { sign.cast }
                else
                    while(1)
                        result = sign.cast
                        break if result !~ /Spell Hindrance/ || !sign.affordable? || dead?
                    end
                end
				
				break if single_cast
            end
        end
    end

    def loot()
        dead_npcs = GameObj.npcs.find_all { |i| i.status == 'dead' }
        dead_npcs.each { |i|
            change_stance('defensive')
            if(@LOOT_SCRIPT)
                run_script( @LOOT_SCRIPT, true )
                break
            else
                bs_put 'loot'
            end
        }
    end

    def prepare_for_movement()
        change_stance('defensive')
        if( leading? && !solo? )
            wait_while { @followers.roundtime? }
            sleep 1
        end
    end

    def bs_wander()
		wander_last_room = nil
		
        wander = proc {
            room = Room.current
            next_room_options = room.wayto.keys - @HUNTING_BOUNDARIES
            if next_room_options.length > 1
                next_room_options.delete_if { |option| option == wander_last_room }
            end
            next_room = next_room_options[rand(next_room_options.length)]
            way = room.wayto[next_room]
            if way.class == String 
				sleep 0.3
                move(way)
            else
                way.call
            end
			cast_signs(true)
            wander_last_room = room.id.to_s
        }
        if GameObj.npcs.size > 0 # last chance to find a target
            sort_npcs.each { |i| return i if valid_target?( i, false ) }
        end
		
        loop { # wander until we find a valid target
            group = checkpcs.to_a
            wander.call
            sleep 0.1
            next unless (checkpcs.to_a - group).empty?
            next if GameObj.loot.find { |obj| (obj.noun == 'disk') and (obj.name !~ /#{group.join('|')}/) }
            start_npcs = npcs = GameObj.npcs
            npcs.delete_if { |npc| (npc.status =~ /dead|gone/) }
            next if npcs.nil? or npcs.empty?
            if npcs.size > 0 # we call this twice.... I don't like it either
                sort_npcs.each { |i| return i if valid_target?( i, true ) }
            end
    	    return if should_rest?
        }
    end

    def bs_put(message)
        unless script = Script.self then respond('--- waitfor: Unable to identify calling script.'); return false; end
        clear
        put(message)

        while string = get
            if string =~ /(?:\.\.\.wait |Wait )[0-9]+/
                hold_up = string.slice(/[0-9]+/).to_i
                sleep(hold_up - 1) unless hold_up.nil? || hold_up == 1
                clear
                put(message)
                next
            elsif string =~ /struggle.+stand/
                clear
                bs_put("stand")
                next
            elsif string =~ /stunned|can't do that while|cannot seem|can't seem|don't seem|Sorry, you may only type ahead/
                if dead?
                    echo("You're dead...! You can't do that!")
                    sleep 0.25
                    script.downstream_buffer.unshift(string)
                    return false
                elsif checkstunned
                    while checkstunned
                        sleep("0.25".to_f)
                    end
                elsif checkwebbed
                    while checkwebbed
                        sleep("0.25".to_f)
                    end
                else
                    sleep(0.25)
                end
                clear
                put(message)
                next
            else
                script.downstream_buffer.unshift(string)
                return string
            end
        end
    end

    # gui
    def self.setup
        Gtk.queue {
            $OP_WINDOW = Gtk::Window.new
            $OP_WINDOW.title = "Big Shot: v#{BIGSHOT_VERSION}"
            $OP_WINDOW.set_border_width(10)
            $OP_BOX = Gtk::VBox.new(false)
            $OP_BOX.set_border_width(5)

            $OP_VERTICAL_BOX1 = Gtk::VBox.new(false, 0)
            $OP_VERTICAL_BOX2 = Gtk::VBox.new(false, 0)
            $OP_VERTICAL_BOX3 = Gtk::VBox.new(false, 0)
            $OP_VERTICAL_BOX4 = Gtk::VBox.new(false, 0)
            $OP_VERTICAL_BOX5 = Gtk::VBox.new(false, 0)
            $OP_VERTICAL_BOX6 = Gtk::VBox.new(false, 0)
            $OP_VERTICAL_BOX7 = Gtk::VBox.new(false, 0)
            $OP_VERTICAL_BOX8 = Gtk::VBox.new(false, 0)

            $OP_WINDOW.add($OP_BOX)
            $OP_NOTEBOOK = Gtk::Notebook.new
            $OP_NOTEBOOK.set_show_border(true)
            $OP_BOX.add($OP_NOTEBOOK)
            $OP_NOTEBOOK.append_page($OP_VERTICAL_BOX1, Gtk::Label.new('General'))
            $OP_NOTEBOOK.append_page($OP_VERTICAL_BOX2, Gtk::Label.new('Resting'))
            $OP_NOTEBOOK.append_page($OP_VERTICAL_BOX3, Gtk::Label.new('Hunting Map'))
            $OP_NOTEBOOK.append_page($OP_VERTICAL_BOX4, Gtk::Label.new('Hunting'))
            $OP_NOTEBOOK.append_page($OP_VERTICAL_BOX5, Gtk::Label.new('Attacking'))
            $OP_NOTEBOOK.append_page($OP_VERTICAL_BOX6, Gtk::Label.new('Should_hunt?')) 
            $OP_NOTEBOOK.append_page($OP_VERTICAL_BOX7, Gtk::Label.new('Should_rest?'))
            $OP_NOTEBOOK.append_page($OP_VERTICAL_BOX8, Gtk::Label.new('Ammo/Wands')) 

            $OP_ENTRY = Hash.new # For mapping entries to variables
            $OP_TABLE_SIZE = Hash.new # For mapping table sizes
        }

        Gtk.queue {
            $OP_TABLE1 = Gtk::Table.new(6, 3, false)
            $OP_TABLE1.row_spacings=3
            $OP_TABLE1.column_spacings=3
            $OP_VERTICAL_BOX1.pack_start($OP_TABLE1, false, false, 0)

            $OP_TABLE2 = Gtk::Table.new(6, 3, false)
            $OP_TABLE2.row_spacings=3
            $OP_TABLE2.column_spacings=3
            $OP_VERTICAL_BOX2.pack_start($OP_TABLE2, false, false, 0)

            $OP_TABLE3 = Gtk::Table.new(6, 3, false)
            $OP_TABLE3.row_spacings=3
            $OP_TABLE3.column_spacings=3
            $OP_VERTICAL_BOX3.pack_start($OP_TABLE3, false, false, 0)

            $OP_TABLE4 = Gtk::Table.new(6, 3, false)
            $OP_TABLE4.row_spacings=3
            $OP_TABLE4.column_spacings=3
            $OP_VERTICAL_BOX4.pack_start($OP_TABLE4, false, false, 0)

            $OP_TABLE5 = Gtk::Table.new(6, 3, false)
            $OP_TABLE5.row_spacings=3
            $OP_TABLE5.column_spacings=3
            $OP_VERTICAL_BOX5.pack_start($OP_TABLE5, false, false, 0)

            $OP_TABLE6 = Gtk::Table.new(6, 3, false)
            $OP_TABLE6.row_spacings=3
            $OP_TABLE6.column_spacings=3
            $OP_VERTICAL_BOX6.pack_start($OP_TABLE6, false, false, 0)

            $OP_TABLE7 = Gtk::Table.new(6, 3, false)
            $OP_TABLE7.row_spacings=3
            $OP_TABLE7.column_spacings=3
            $OP_VERTICAL_BOX7.pack_start($OP_TABLE7, false, false, 0)

            $OP_TABLE8 = Gtk::Table.new(6, 3, false)
            $OP_TABLE8.row_spacings=3
            $OP_TABLE8.column_spacings=3
            $OP_VERTICAL_BOX8.pack_start($OP_TABLE8, false, false, 0)
        }

        def self.add_label_entry(table, label, variable)
            size = $OP_TABLE_SIZE[table] || 0

            label = Gtk::Label.new(label)
            align = Gtk::Alignment.new 1, 0, 0, 0
            align.set_padding(4, 0, 3, 4)
            align.add(label)
            table.attach(align, 0, 1, size, size + 1)

            entry = Gtk::Entry.new
            entry.text = UserVars.op[variable].to_s
            entry.set_width_request(157)
            table.attach(entry, 1, 2, size, size + 1)

            $OP_ENTRY[variable] = entry
            $OP_TABLE_SIZE[table] += 1
        end

        Gtk.queue {
            $OP_ENTRY = Hash.new
            add_label_entry($OP_TABLE2, "*room id:", 'resting_room_id')
            add_label_entry($OP_TABLE2, "pre-rest commands:", 'resting_commands')
            add_label_entry($OP_TABLE2, "active resting scripts:", 'resting_scripts')
            add_label_entry($OP_TABLE3, "*starting room ID:", 'hunting_room_id')
            add_label_entry($OP_TABLE3, "*boundary rooms:", 'hunting_boundaries') 
            add_label_entry($OP_TABLE4, "valid targets:", 'targets')
            add_label_entry($OP_TABLE4, "attack stance:", 'hunting_stance')
            add_label_entry($OP_TABLE4, "pre-hunt commands:", 'hunting_prep_commands')
            add_label_entry($OP_TABLE4, "active hunting scripts:", 'hunting_scripts')
            add_label_entry($OP_TABLE4, "society abilities/spells/cmans:", 'signs')
            add_label_entry($OP_TABLE4, "loot script:", 'loot_script')
            add_label_entry($OP_TABLE4, "wracking spirit >=", 'wracking_spirit')
            add_label_entry($OP_TABLE5, "*hunting commands:", 'hunting_commands')
            add_label_entry($OP_TABLE5, "hunting commands(b):", 'hunting_commands_b')
            add_label_entry($OP_TABLE5, "hunting commands(c):", 'hunting_commands_c')
            add_label_entry($OP_TABLE5, "fried hunting commands:", 'disable_commands')
            add_label_entry($OP_TABLE5, "flee if enemy count is >", 'flee_count')
            add_label_entry($OP_TABLE5, "...but don't count these:", 'invalid_targets')
            add_label_entry($OP_TABLE5, "...and always flee from:", 'always_flee_from')
            add_label_entry($OP_TABLE6, "*when percentmind <=", 'rest_till_exp')
            add_label_entry($OP_TABLE6, "...*and percentmana >=", 'rest_till_mana')
            add_label_entry($OP_TABLE6, "...and CHECKspirit >=", 'rest_till_spirit')
            add_label_entry($OP_TABLE7, "*when percentmind >=", 'fried')
            add_label_entry($OP_TABLE7, "...*or percentmana <=", 'oom')
            add_label_entry($OP_TABLE7, "...or percentencumbrance >=", 'encumbered')
            add_label_entry($OP_TABLE7, "...or wounded eval:", 'wounded_eval')
            add_label_entry($OP_TABLE8, "find ammo in this container:", 'ammo_container')
            add_label_entry($OP_TABLE8, "use this ammo type:", 'ammo')
            add_label_entry($OP_TABLE8, "fresh wand container:", 'fresh_wand_container')
            add_label_entry($OP_TABLE8, "dead wand container:", 'dead_wand_container')
            add_label_entry($OP_TABLE8, "use this wand type:", 'wand')
        }

        def self.add_checkbox(table, x_pos, label, variable, default = false)
            size = $OP_TABLE_SIZE[table] || 0
            checkbox = Gtk::CheckButton.new label
            value = UserVars.op[variable].nil? ? default : UserVars.op[variable]
            checkbox.set_active(value)
            table.attach(checkbox, x_pos, x_pos + 1, size, size + 1)
            $OP_ENTRY[variable] = checkbox
            $OP_TABLE_SIZE[table] += 1 if x_pos == 1
        end
 
        Gtk.queue {
            add_checkbox($OP_TABLE1, 0, "Engage deadmans switch", 'dead_man_switch')
            add_checkbox($OP_TABLE1, 1, "Monitor interaction", 'monitor_interaction')
            add_checkbox($OP_TABLE1, 0, "Depart/rerun if dead", 'depart_switch')
            add_checkbox($OP_TABLE1, 1, "Flee from clouds", 'flee_clouds') 
            add_checkbox($OP_TABLE4, 1, "Use sign of wracking/sigil of power", 'use_wracking')
            add_checkbox($OP_TABLE5, 1, "Spam attacks (recommended)", 'spam', true)
            add_checkbox($OP_TABLE5, 1, "Approach lone targets only", 'lone_targets_only', false)
            add_checkbox($OP_TABLE8, 1, "Hide while waiting to pick up ammo", 'hide_for_ammo')
            add_checkbox($OP_TABLE8, 1, "Use wands when out of mana", 'wand_if_oom')
        }
        
        Gtk.queue {
            $OP_WINDOW.signal_connect("delete_event") {
                $OP_SETUP_COMPLETED = true
            }
        }
        
        Gtk.queue {
            $OP_TOOLTIPS = Gtk::Tooltips.new
            $OP_TOOLTIPS.enable

            label = Gtk::Label.new
            label.set_markup("<i>Bigshot is the leader of the Battle Patrol.\nHe comes equipped with a gun as long as his entire superstructure.\nTakes the edge off.\n\n\n***Settings with * are required.***</i>")
            align = Gtk::Alignment.new(1, 0, 0, 0)
            align.set_padding(50, 0, 0, 40)
            align.add(label)
            $OP_TABLE1.attach(align, 1, 2, 8, 9)

            commands_tip =  "Example 1: 413 target, 903 target\nExample 2: 903 target(x2)\nExample 3: 903 target(xx)\nExample 4: 910 target(m50), 903 target\n\nExample 1 will cast 413 then 903 on the target. Example 2 will cast 903 on the target twice. Example 3 will cast 903 on the target until the fight is over. Example 4 will cast 910 if mana is at least 50, otherwise it will cast 903. Separate all commands with commas.\n\nNew feature: 'and'.\nFor example: stance def and 1615 target, kill target(xx)"
            $OP_TOOLTIPS.set_tip($OP_ENTRY['hunting_commands'], commands_tip, "")
            $OP_TOOLTIPS.set_tip($OP_ENTRY['g_hunting_commands'], commands_tip, "")
            $OP_TOOLTIPS.set_tip($OP_ENTRY['g_disable_commands'], commands_tip, "")

            signs_tip = "Combat Movement - 9601\nCombat Focus - 9602\nShadow Mastery - 9603\nSurge of Strength - 9605\n\nSigil of Contact - 9703\nSigil of Resolve - 9704\nSigil of Minor Bane - 9705\nSigil of Defense - 9707\nSigil of Offense - 9708\nSigil of Minor Protection - 9710\nSigil of Focus - 9711\nSigil of Mending - 9713\nSigil of Concentration - 9714\nSigil of Major Bane - 9715\nSigil of Major Determination - 9716\nSigil of Major Protection - 9719\n\nSign of Warding - 9903\nSign of Striking - 9904\nSign of Thought - 9906\nSign of Defending - 9907\nSign of Smiting - 9908\nSign of Staunching - 9909\nSign of Deflection - 9910\nSign of Swords - 9912\nSign of Shields - 9913\nSign of Dissipation - 9914\nSign of Madness - 9916\n\nSymbol of Courage - 9805\nSymbol of Protection - 9806"
            $OP_TOOLTIPS.set_tip($OP_ENTRY['signs'], signs_tip, "")

            size = $OP_TABLE_SIZE[$OP_TABLE3]
            label = Gtk::Label.new
            label.set_markup("<i>Note: Big Shot will not enter boundary rooms. The goal is to pin yourself into a hunting area.</i>")
            align = Gtk::Alignment.new(1, 0, 0, 0)
            align.set_padding(75, 0, 0, 4)
            align.add(label)
            $OP_TABLE3.attach(align, 1, 2, size, size + 1)

            size = $OP_TABLE_SIZE[$OP_TABLE4]
            label = Gtk::Label.new
            label.set_markup("<i>Note: Use nouns for targets. Mouse over society abilities field for more info.</i>")
            align = Gtk::Alignment.new(1, 0, 0, 0)
            align.set_padding(0, 0, 0, 4)
            align.add(label)
            $OP_TABLE4.attach(align, 1, 2, size, size + 1)

            size = $OP_TABLE_SIZE[$OP_TABLE5]
            label = Gtk::Label.new
            label.set_markup("<i>Note: Use nouns for flee info. Mouse over some hunting commands field for more info.</i>")
            align = Gtk::Alignment.new(1, 0, 0, 0)
            align.set_padding(0, 0, 0, 4)
            align.add(label)
            $OP_TABLE5.attach(align, 1, 2, size, size + 1)

            $OP_WINDOW.show_all
        }
        
        $OP_SETUP_COMPLETED = false
        until($OP_SETUP_COMPLETED)
            sleep 1
        end
       
        UserVars.op ||= Hash.new
        $OP_ENTRY.keys.each { |key|
            if( $OP_ENTRY[key].class.to_s =~ /CheckButton/ )
                value = $OP_ENTRY[key].active?
                UserVars.op[key] = $OP_ENTRY[key].active?
            else
                if(key == 'wounded_eval')
                    UserVars.op[key] = $OP_ENTRY[key].text
                else
                    UserVars.op[key] = $OP_ENTRY[key].text.strip.downcase
                end
            end
        }
        UserVars.save()
        
        Gtk.queue {
            $OP_WINDOW.destroy
        }
    end
end

if( script.vars[1].nil? || script.vars[1] =~ /solo|(bounty)/i )
    bounty_mode = $1

    bs = Bigshot.new(bounty_mode)
    bs.croak('Requires Lich V4') unless defined?(Gtk.queue)
    bs.croak('Requires a mapped room.') if( Room.current.id.nil? || Room.current.id == 4 )
    bs.lead()

elsif( script.vars[1] =~ /setup/i )
    Bigshot.setup()

elsif( script.vars[1] =~ /display/i )
    echo "Version: #{BIGSHOT_VERSION}"
    UserVars.op.each_pair { |k, v|
        echo "#{k}: #{v}" unless v.nil? || v.class.to_s == 'Array' || v =~ /^\s*$/
    }

elsif( script.vars[1] =~ /head/i )
    # launch DRb server
    DRb.start_service( nil, Group.new )
    uri = DRb.uri
    Thread.new { DRb.thread.join }

    # launch DRb client
    DRb.start_service()
    bs = Bigshot.new()

    # set leader
    my_group = DRbObject.new( nil, uri )
    my_group.set_leader(bs)

    # announce/go
    (1..RALLY_TIME).each { |i| fput "whisper group Bigshot rallying at #{uri}"; sleep 1; }
    bs.lead(my_group)

elsif( script.vars[1] =~ /tail/i )
    # Watch for rally
    group = nil
    bs = nil
    while( group.nil? && bs.nil? )
        if( get =~ /rallying at (.*)\."$/ )

            # create group
            DRb.start_service()
            group = DRbObject.new( nil, $1 )

            # create Bigshot
            bs = Bigshot.new()
            group.add_member(bs)
            bs.keep_awake()
        end
    end

    # Participate
    bs.message("Joined group")
    leader = group.leader.name

    while(!dead?)
        begin
            bs.change_stance('defensive')
            bs.stand()
            sleep 0.25
            
            # grab event
            event = bs.event_stack.size == 0 ? nil : bs.grab_event
            next if event.nil?
            
            # kertwang!
            until( checkpcs.include?(leader) )
                start_script( 'go2', [ group.room_id, '_disable_confirm_' ] )
                wait_while { running?('go2') }
                fput "join #{leader}"
                sleep 1
            end
    
            # process event
            bs.message("event: " + event.type.to_s)
            if( event.type == :HUNTING_PREP_COMMANDS )
                bs.HUNTING_PREP_COMMANDS.each { |i| fput(i) }
    
            elsif( event.type == :CAST_SIGNS )
                bs.cast_signs()
    
            elsif( event.type == :HUNTING_SCRIPTS_START )
                bs.run_scripts( bs.HUNTING_SCRIPTS, false )
    
            elsif( event.type == :ATTACK )
                if( event.stale? ) # consider timestamp and room_id
                    bs.message("skipping attack because it's stale")
                    next
                end

                target = nil
                while( target = bs.find_target(target) )
                    break if event.room_id != Room.current.id # only consider room_id
                    bs.attack(target)
                end
    
            elsif( event.type == :HUNTING_SCRIPTS_STOP )
                bs.croak_scripts(bs.HUNTING_SCRIPTS)
    
            elsif( event.type == :RESTING_PREP_COMMANDS )
                $bigshot_should_rest = nil # need to reset this
                bs.RESTING_COMMANDS.each { |i| fput(i) }
    
            elsif( event.type == :RESTING_SCRIPTS_START )
                bs.run_scripts( bs.RESTING_SCRIPTS, true )
    
            elsif( event.type == :DISPLAY_WATCH )
                if( event.stale? )
                    bs.message("skipping display_watch because it's stale")
                    next
                end
                bs.message( "Bigshot last rested because: #{$rest_reason}" ) if $rest_reason
                bs.message( "Bigshot isn't hunting because: #{$not_hunting_reason}" ) if $not_hunting_reason
                sleep( REST_INTERVAL / 10 )
            end

        rescue
            fput 'leave group'
            if( bs.RESTING_ROOM_ID && bs.RESTING_ROOM_ID != 4 )
                start_script( 'go2', [ bs.RESTING_ROOM_ID, '_disable_confirm_' ] )
                wait_while { running?('go2') }
            end
            echo "Fatal exception!"
            echo $!.to_s
            echo $!.backtrace.join("\n")
            Script.self.kill
        end
    end
end 

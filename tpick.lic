=begin

	This script will disarm, measure, pick (and will use the appropriate lockpick based on your skill and lock difficulty) and empty your boxes into your container. This script can also be used to automatically accept, disarm, 			measure, pick and hand back other people's boxes.
	
	Script will attempt to read lock difficulty for Rogues using calipers and for Bards using loresinging. If you are a Rogue or Bard and would prefer to skip all that and always use a vaalin lock pick instead then use the v variables listed below.

	Script will attempt to use vials bundled into your locksmith's pouch first for plated boxes, if no vials are bundled into your locksmith's pouch it will attempt to use wedges found in your wedge sack.

	Usage:
	;tpick <setup> must be done first before you can use this script. Be sure to fill out all of the settings.

	Use the following command line variables for how you want the script to run:

	other - will accept boxes handed to you, pick them, then hand them back to the person who handed you the box.
	ground - will pick all boxes on the ground but will not take loot out of them. Useful if you're picking boxes on the ground for someone else.
	Not using "other" or "ground" will pick all boxes inside of your open containers and inside your disk.

	v - will skip measuring locks and always use a vaalin lockpick + 403 to pick all boxes.
	loot - to pick all boxes on the ground and take the loot out of each box.
	relock - will relock the box after it has been opened and looted. Only works if you're picking your own boxes or you use both the ground and loot command line variables.
	pop - this will attempt to open boxes using 407 and 408 only. Does not work with the "other" variable but does work with "ground" picking. This option requires the knowledge of Piercing Gaze (416).

	The above commands can be used in any combination. Some examples:
	
	;tpick other v - will pick other people's boxes and always use a vaalin lockpick.
	;tpick loot ground v - will pick all boxes on the ground, will loot each box after picking them, and will always use a vaalin lockpick.
	;tpick - will pick all boxes in your open containers.


	The following commands cannot be used with the above commands:

	buy - script will fill up your locksmith's container with cotton balls and putty by buying them at the locksmith's shop. Script will exit once done.
	repair - script will repair any lockpicks that need repairing. Must be a rogue with the lmas skill to repair lockpicks.
	Currently repair only works in Icemule, Landing, Sol Haven and Illistim.


	Non Rogues and bards do not need to use the "v" command line, they will always pick boxes with a vaalin lockpick and won't use calipers.
	
	Author: Tgo01
	Version 81

=end

number_of_manual_trap_checks_remaining = nil
second_trap_check = nil
check_for_command = nil
gem = nil
reagent = nil
herb = nil
food = nil
uncommon = nil
jewelry = nil
junk = nil
lockpick = nil
magic = nil
scroll = nil
wand = nil
armor = nil
weapon = nil
clothing = nil
other = nil
stow_in_disk = nil
check_for_boxes = nil
remaining_416_casts = nil
stuff_to_do = nil
where_to_stow_box = nil
check_locksmiths_container = nil
putty_remaining = nil
cotton_remaining = nil
vials_remaining = nil
fill_up_locksmith_container = nil
order_number = nil
trash_container = nil
current_vial = nil
use_spell_205 = nil
use_spell_402 = nil
use_spell_403 = nil
use_spell_404 = nil
use_spell_506 = nil
use_spell_613 = nil
use_spell_704 = nil
use_spell_1006 = nil
pop_start = nil
before_needed_pick = nil
check_hands_status = nil
current_trap_type = nil
box_is_disarmed = nil
box_is_open = nil
check_for_trap = nil
pop_open_box = nil
disarm_trap = nil
cast_402 = nil
cast_403 = nil
cast_404 = nil
can_use_calipers = nil
pop_boxes_begin = nil
fused_lock_disarm = nil
starting_room = Room.current.id
$tpick_list_of_box_ids = Array.new
$tpick_copper_wire = nil unless $tpick_copper_wire
$tpick_copper_wire_cost = nil unless $tpick_copper_wire_cost
$tpick_brass_wire = nil unless $tpick_brass_wire
$tpick_brass_wire_cost = nil unless $tpick_brass_wire_cost
$tpick_steel_wire = nil unless $tpick_steel_wire
$tpick_steel_wire_cost = nil unless $tpick_steel_wire_cost
$tpick_gold_wire = nil unless $tpick_gold_wire
$tpick_gold_wire_cost = nil unless $tpick_gold_wire_cost
$tpick_silver_wire = nil unless $tpick_silver_wire
$tpick_silver_wire_cost = nil unless $tpick_silver_wire_cost
$tpick_ora_wire = nil unless $tpick_ora_wire
$tpick_ora_wire_cost = nil unless $tpick_ora_wire_cost
$tpick_mithril_wire = nil unless $tpick_mithril_wire
$tpick_mithril_wire_cost = nil unless $tpick_mithril_wire_cost
$tpick_laje_wire = nil unless $tpick_laje_wire
$tpick_laje_wire_cost = nil unless $tpick_laje_wire_cost
$tpick_alum_wire = nil unless $tpick_alum_wire
$tpick_alum_wire_cost = nil unless $tpick_alum_wire_cost
$tpick_vultite_wire = nil unless $tpick_vultite_wire
$tpick_vultite_wire_cost = nil unless $tpick_vultite_wire_cost
$tpick_rolaren_wire = nil unless $tpick_rolaren_wire
$tpick_rolaren_wire_cost = nil unless $tpick_rolaren_wire_cost
$tpick_veniom_wire = nil unless $tpick_veniom_wire
$tpick_veniom_wire_cost = nil unless $tpick_veniom_wire_cost
$tpick_kelyn_wire = nil unless $tpick_kelyn_wire
$tpick_kelyn_wire_cost = nil unless $tpick_kelyn_wire_cost
$tpick_invar_wire = nil unless $tpick_invar_wire
$tpick_invar_wire_cost = nil unless $tpick_invar_wire_cost
$tpick_golvern_wire = nil unless $tpick_golvern_wire
$tpick_golvern_wire_cost = nil unless $tpick_golvern_wire_cost
$tpick_vaalin_wire = nil unless $tpick_vaalin_wire
$tpick_vaalin_wire_cost = nil unless $tpick_vaalin_wire_cost
get_wire_order_numbers = nil
current_pick_to_check = nil
appraise_current_pick = nil
lockpick_type = nil
current_wire = nil
current_wire_cost = nil
popping = nil
gem_container = nil
start_sorter = nil
lockpick_full_name = Array.new
lockpick_full_name_number = 1
toolbenches_room_number = [ '17978', '16574', '17960', '17881' ]
scale_trap_weapon_full_name = UserVars.tpick["scale_trap_weapon"]

lockpick_full_name[1] = UserVars.tpick["copper"]
lockpick_full_name[2] = UserVars.tpick["steel"]
lockpick_full_name[3] = UserVars.tpick["gold"]
lockpick_full_name[4] = UserVars.tpick["silver"]
lockpick_full_name[5] = UserVars.tpick["mithril"]
lockpick_full_name[6] = UserVars.tpick["ora"]
lockpick_full_name[7] = UserVars.tpick["glaes"]
lockpick_full_name[8] = UserVars.tpick["laje"]
lockpick_full_name[9] = UserVars.tpick["vultite"]
lockpick_full_name[10] = UserVars.tpick["rolaren"]
lockpick_full_name[11] = UserVars.tpick["veniom"]
lockpick_full_name[12] = UserVars.tpick["invar"]
lockpick_full_name[13] = UserVars.tpick["alum"]
lockpick_full_name[14] = UserVars.tpick["golvern"]
lockpick_full_name[15] = UserVars.tpick["kelyn"]
lockpick_full_name[16] = UserVars.tpick["vaalin"]

lockpick_full_name.each { |lockpick|
	if lockpick =~ /([a-zA-Z]+)\s([a-zA-Z]+)/
		first_word = $1
		second_word = $2
		lockpick_full_name[lockpick_full_name_number] = /.*#{first_word}.*#{second_word}/
		lockpick_full_name_number += 1
	end
}

if scale_trap_weapon_full_name =~ /([a-zA-Z]+)\s([a-zA-Z]+)/
	first_word = $1
	second_word = $2
	scale_trap_weapon_full_name = /.*#{first_word}.*#{second_word}/
end

$tpick_boxes_checked = nil
strongbox_count = 0
box_count = 0
chest_count = 0
trunk_count = 0
coffer_count = 0

gem_number = Array.new
reagent_number = Array.new
herb_number = Array.new
food_number = Array.new
uncommon_number = Array.new
jewelry_number = Array.new
junk_number = Array.new
lockpick_number = Array.new
magic_number = Array.new
scroll_number = Array.new
wand_number = Array.new
armor_number = Array.new
weapon_number = Array.new
clothing_number = Array.new
other_number = Array.new

#The following is just for informational purposes, no need to change anything.

#Pick names and mod values:
#Copper		1.00
#Steel		1.10
#Gold		1.20
#Silver		1.30
#Mithril	1.45
#Ora		1.55
#Glaes		1.60
#Laje		1.75
#Vultite	1.80
#Rolaren	1.90
#Veniom		2.20
#Invar		2.25
#Alum		2.30
#Golvern	2.35
#Kelyn		2.40
#Vaalin		2.50

#Lock names and difficulty
#Primitive			35
#Rudimentary			75
#Extremely Easy			115
#Very Easy			155
#Easy				195
#Very Basic			235
#Fairly Easy			275
#Simple				315
#Fairly Simple			355
#Fairly Plain			395
#Moderately Well-Crafted	435
#Well-Crafted			475
#Tricky				515
#Somewhat Difficult		555
#Moderately Difficult		595
#Very Well-Crafted		635
#Difficult			675
#Extremely Well-Crafted		715
#Very Difficult			755
#Fairly Complicated		795
#Intricate			835
#Amazingly Well-Crafted		875
#Very Complex			915
#Impressively Complicated	955
#Amazingly Intricate		995
#Extremely Difficult		1035
#Extremely Complex		1075
#Masterfully Well-Crafted	1115
#Amazingly Complicated		1155
#Astoundingly Complex		1195
#Incredibly Intricate		1235
#Absurdly Well-Crafted		1275
#Exceedingly Complex		1315
#Absurdly Difficult		1355
#Unbelievably Complicated 	1395
#Masterfully Intricate		1435
#Absurdly Complex		1475
#Impossibly Complex		1515

#
#
#Don't change anything below unless you know what you are doing.
#
#

pick_mod = [ 1.00, 1.10, 1.20, 1.30, 1.45, 1.55, 1.60, 1.75, 1.80, 1.90, 2.20, 2.25, 2.30, 2.35, 2.40, 2.50 ]
lock_difficulty = [ 35, 75, 115, 155, 195, 235, 275, 315, 355, 395, 435, 475, 515, 555, 595, 635, 675, 715, 755, 795, 835, 875, 915, 955, 995, 1035, 1075, 1115, 1155, 1195, 1235, 1275, 1315, 1355, 1395, 1435, 1475, 1515 ]
pick_skill = (Skills.to_bonus(Skills.pickinglocks) + Stats.dex[1])
pick_lore = (Stats.level / 2) + (Skills.to_bonus(Skills.pickinglocks) / 10) + (Stats.dex[1]) + (Spells.minorelemental / 4)
pick_lore = Skills.pickinglocks if pick_lore > Skills.pickinglocks
disarm_skill = (Stats.dex[1] + Skills.to_bonus(Skills.disarmingtraps))
if Spell[404].known?
	disarm_lore = (Stats.level / 2) + (Skills.to_bonus(Skills.disarmingtraps) / 10) + (Stats.agi[1] / 2) + (Stats.dis[1] / 2)
else
	disarm_lore = 0
end
(stow_left = nil;stow_right = nil;start_solo = nil;start_others = nil;disk = nil;manually_disarm_trap = nil;sphere_trap = nil;scale = nil;scaledisarm = nil;scarab = nil;plate = nil;measure = nil;pick2 = nil;pick3 = nil;nextpick = nil;open_solo = nil;open_others = nil;need_403 = nil;needed_pick = nil;pick = nil;total_pick_skill = nil;scarab2 = nil;person = nil;box = "box";cast_404 = nil;solo_or_other = nil;always_use_vaalin = nil;wedge_lock = nil;ground_loot = nil;start_ground = nil;current_box = nil;setup = nil;do_trick = nil;calibrate = nil;cast_403 = nil;cast_402 = nil;cast_613 = nil;cast_205 = nil;cast_1006 = nil;cast_506 = nil;calibrate_count = nil;cast_407 = nil;current_box_name = nil;close_wedge_sack = nil;close_calipers_sack = nil;close_lockpick_sack = nil;close_scaleweapon_sack = nil;close_broken_lockpick_container = nil;box_opened = true;cant_open_plated_box_count = nil;total_boxes_picked = 0;record_item_data = nil;silver_before = nil;silver_after = nil;wealth_before = nil;wealth_after = nil;silver_gained = 0;trash = nil;garbage_check = nil;trap_difficulty = nil;need_404 = nil;total_trap_skill = nil;broken_lockpick_stow = nil;relock_boxes = nil;do_relock_boxes = nil)

trash_container = /crate|barrel|wastebarrel|casket|bin|receptacle|basket/i

setup = proc{
	UserVars.tpick["copper"] = "copper lockpick" if UserVars.tpick["copper"].nil? or UserVars.tpick["copper"].empty?
	UserVars.tpick["steel"] = "steel lockpick" if UserVars.tpick["steel"].nil? or UserVars.tpick["steel"].empty?
	UserVars.tpick["gold"] = "gold lockpick" if UserVars.tpick["gold"].nil? or UserVars.tpick["gold"].empty?
	UserVars.tpick["silver"] = "silver lockpick" if UserVars.tpick["silver"].nil? or UserVars.tpick["silver"].empty?
	UserVars.tpick["mithril"] = "mithril lockpick" if UserVars.tpick["mithril"].nil? or UserVars.tpick["mithril"].empty?
	UserVars.tpick["ora"] = "ora lockpick" if UserVars.tpick["ora"].nil? or UserVars.tpick["ora"].empty?
	UserVars.tpick["glaes"] = "glaes lockpick" if UserVars.tpick["glaes"].nil? or UserVars.tpick["glaes"].empty?
	UserVars.tpick["laje"] = "laje lockpick" if UserVars.tpick["laje"].nil? or UserVars.tpick["laje"].empty?
	UserVars.tpick["vultite"] = "vultite lockpick" if UserVars.tpick["vultite"].nil? or UserVars.tpick["vultite"].empty?
	UserVars.tpick["rolaren"] = "rolaren lockpick" if UserVars.tpick["rolaren"].nil? or UserVars.tpick["rolaren"].empty?
	UserVars.tpick["veniom"] = "veniom lockpick" if UserVars.tpick["veniom"].nil? or UserVars.tpick["veniom"].empty?
	UserVars.tpick["invar"] = "invar lockpick" if UserVars.tpick["invar"].nil? or UserVars.tpick["invar"].empty?
	UserVars.tpick["alum"] = "alum lockpick" if UserVars.tpick["alum"].nil? or UserVars.tpick["alum"].empty?
	UserVars.tpick["golvern"] = "golvern lockpick" if UserVars.tpick["golvern"].nil? or UserVars.tpick["golvern"].empty?
	UserVars.tpick["kelyn"] = "kelyn lockpick" if UserVars.tpick["kelyn"].nil? or UserVars.tpick["kelyn"].empty?
	UserVars.tpick["vaalin"] = "vaalin lockpick" if UserVars.tpick["vaalin"].nil? or UserVars.tpick["vaalin"].empty?
	UserVars.tpick["lockpick_container"] = "keyring" if UserVars.tpick["lockpick_container"].nil? or UserVars.tpick["lockpick_container"].empty?
	UserVars.tpick["wedge_container"] = "kit" if UserVars.tpick["wedge_container"].nil? or UserVars.tpick["wedge_container"].empty?
	UserVars.tpick["calipers_container"] = "kit" if UserVars.tpick["calipers_container"].nil? or UserVars.tpick["calipers_container"].empty?
	UserVars.tpick["scale_trap_weapon"] = "pick" if UserVars.tpick["scale_trap_weapon"].nil? or UserVars.tpick["scale_trap_weapon"].empty?
	UserVars.tpick["always_use_404"] = "yes" if UserVars.tpick["always_use_404"].nil? or UserVars.tpick["always_use_404"].empty?
	UserVars.tpick["lock_roll"] = 50 if UserVars.tpick["lock_roll"].nil? or UserVars.tpick["lock_roll"].empty?
	UserVars.tpick["vaalin_lock_roll"] = 60 if UserVars.tpick["vaalin_lock_roll"].nil? or UserVars.tpick["vaalin_lock_roll"].empty?
	Gtk.queue {
		$OP_WINDOW = Gtk::Window.new
		$OP_WINDOW.title = "tpick"
		$OP_WINDOW.set_border_width(10)
		$OP_BOX = Gtk::VBox.new(false)
		$OP_BOX.set_border_width(5)

		$OP_VERTICAL_BOX1 = Gtk::VBox.new(false, 0)
		$OP_VERTICAL_BOX2 = Gtk::VBox.new(false, 0)
		$OP_VERTICAL_BOX3 = Gtk::VBox.new(false, 0)
		$OP_VERTICAL_BOX4 = Gtk::VBox.new(false, 0)
		$OP_VERTICAL_BOX5 = Gtk::VBox.new(false, 0)
		$OP_VERTICAL_BOX6 = Gtk::VBox.new(false, 0)
		$OP_VERTICAL_BOX7 = Gtk::VBox.new(false, 0)
		$OP_VERTICAL_BOX8 = Gtk::VBox.new(false, 0)
		$OP_VERTICAL_BOX9 = Gtk::VBox.new(false, 0)

		$OP_WINDOW.add($OP_BOX)
		$OP_NOTEBOOK = Gtk::Notebook.new
		$OP_NOTEBOOK.set_show_border(true)
		$OP_BOX.add($OP_NOTEBOOK)
		$OP_NOTEBOOK.append_page($OP_VERTICAL_BOX1, Gtk::Label.new('Lockpicks'))
		$OP_NOTEBOOK.append_page($OP_VERTICAL_BOX2, Gtk::Label.new('More Lockpicks'))
		$OP_NOTEBOOK.append_page($OP_VERTICAL_BOX3, Gtk::Label.new('Containers'))
		$OP_NOTEBOOK.append_page($OP_VERTICAL_BOX4, Gtk::Label.new('Other'))
		$OP_NOTEBOOK.append_page($OP_VERTICAL_BOX5, Gtk::Label.new('More Other'))
		$OP_NOTEBOOK.append_page($OP_VERTICAL_BOX6, Gtk::Label.new('Spells'))
		$OP_NOTEBOOK.append_page($OP_VERTICAL_BOX7, Gtk::Label.new('Experience'))
		$OP_NOTEBOOK.append_page($OP_VERTICAL_BOX8, Gtk::Label.new('Speech'))
		$OP_NOTEBOOK.append_page($OP_VERTICAL_BOX9, Gtk::Label.new('Popping'))
		$OP_ENTRY = Hash.new 
		$OP_TABLE_SIZE = Hash.new
	}

	Gtk.queue {
		$OP_TABLE1 = Gtk::Table.new(6, 3, false)
		$OP_TABLE1.row_spacings=3
		$OP_TABLE1.column_spacings=3
		$OP_VERTICAL_BOX1.pack_start($OP_TABLE1, false, false, 0)

		$OP_TABLE2 = Gtk::Table.new(6, 3, false)
		$OP_TABLE2.row_spacings=3
		$OP_TABLE2.column_spacings=3
		$OP_VERTICAL_BOX2.pack_start($OP_TABLE2, false, false, 0)

		$OP_TABLE3 = Gtk::Table.new(6, 3, false)
		$OP_TABLE3.row_spacings=3
		$OP_TABLE3.column_spacings=3
		$OP_VERTICAL_BOX3.pack_start($OP_TABLE3, false, false, 0)

		$OP_TABLE4 = Gtk::Table.new(6, 3, false)
		$OP_TABLE4.row_spacings=3
		$OP_TABLE4.column_spacings=3
		$OP_VERTICAL_BOX4.pack_start($OP_TABLE4, false, false, 0)

		$OP_TABLE5 = Gtk::Table.new(6, 3, false)
		$OP_TABLE5.row_spacings=3
		$OP_TABLE5.column_spacings=3
		$OP_VERTICAL_BOX5.pack_start($OP_TABLE5, false, false, 0)

		$OP_TABLE6 = Gtk::Table.new(6, 3, false)
		$OP_TABLE6.row_spacings=3
		$OP_TABLE6.column_spacings=3
		$OP_VERTICAL_BOX6.pack_start($OP_TABLE6, false, false, 0)

		$OP_TABLE7 = Gtk::Table.new(6, 3, false)
		$OP_TABLE7.row_spacings=3
		$OP_TABLE7.column_spacings=3
		$OP_VERTICAL_BOX7.pack_start($OP_TABLE7, false, false, 0)

		$OP_TABLE8 = Gtk::Table.new(6, 3, false)
		$OP_TABLE8.row_spacings=3
		$OP_TABLE8.column_spacings=3
		$OP_VERTICAL_BOX8.pack_start($OP_TABLE8, false, false, 0)

		$OP_TABLE9 = Gtk::Table.new(6, 3, false)
		$OP_TABLE9.row_spacings=3
		$OP_TABLE9.column_spacings=3
		$OP_VERTICAL_BOX9.pack_start($OP_TABLE9, false, false, 0)
	}

	def self.add_label_entry(table, label, variable)
		size = $OP_TABLE_SIZE[table] || 0

		label = Gtk::Label.new(label)
		align = Gtk::Alignment.new 1, 0, 0, 0
		align.set_padding(4, 0, 3, 4)
		align.add(label)
		table.attach(align, 0, 1, size, size + 1)

		entry = Gtk::Entry.new
		entry.text = UserVars.tpick[variable].to_s
		entry.set_width_request(157)
		table.attach(entry, 1, 2, size, size + 1)

		$OP_ENTRY[variable] = entry
		$OP_TABLE_SIZE[table] += 1
	end

	Gtk.queue {
		$OP_ENTRY = Hash.new
		add_label_entry($OP_TABLE1, "Copper Lockpick", 'copper')
		add_label_entry($OP_TABLE1, "Steel Lockpick", 'steel')
		add_label_entry($OP_TABLE1, "Gold Lockpick", 'gold')
		add_label_entry($OP_TABLE1, "Silver Lockpick", 'silver')
		add_label_entry($OP_TABLE1, "Mithril Lockpick", 'mithril')
		add_label_entry($OP_TABLE1, "Ora Lockpick", 'ora')
		add_label_entry($OP_TABLE1, "Glaes Lockpick", 'glaes')
		add_label_entry($OP_TABLE1, "Laje Lockpick", 'laje')
		add_label_entry($OP_TABLE2, "Vultite Lockpick", 'vultite')
		add_label_entry($OP_TABLE2, "Rolaren Lockpick", 'rolaren')
		add_label_entry($OP_TABLE2, "Veniom Lockpick", 'veniom')
		add_label_entry($OP_TABLE2, "Invar Lockpick", 'invar')
		add_label_entry($OP_TABLE2, "Alum Lockpick", 'alum')
		add_label_entry($OP_TABLE2, "Golvern Lockpick", 'golvern')
		add_label_entry($OP_TABLE2, "Kelyn Lockpick", 'kelyn')
		add_label_entry($OP_TABLE2, "Vaalin Lockpick", 'vaalin')
		add_label_entry($OP_TABLE3, "Lockpick Container", 'lockpick_container')
		add_label_entry($OP_TABLE3, "Broken Lockpick Container", 'broken_lockpick_container')
		add_label_entry($OP_TABLE3, "Wedge Container", 'wedge_container')
		add_label_entry($OP_TABLE3, "Calipers Container", 'calipers_container')
		add_label_entry($OP_TABLE3, "Scale Weapon Container", 'scale_weapon_container')
		add_label_entry($OP_TABLE3, "Locksmith's Container", 'locksmiths_container')
		#add_label_entry($OP_TABLE4, "Run silently", 'run_silently')
		add_label_entry($OP_TABLE4, "Scale Trap Weapon", 'scale_trap_weapon')
		add_label_entry($OP_TABLE4, "Trap Roll", 'trap_roll')
		add_label_entry($OP_TABLE4, "Lock Roll", 'lock_roll')
		add_label_entry($OP_TABLE4, "Vaalin Lock Roll", 'vaalin_lock_roll')
		add_label_entry($OP_TABLE4, "Gem Container", 'gem_container')
		add_label_entry($OP_TABLE5, "Trick", 'trick')
		add_label_entry($OP_TABLE5, "Log", 'log')
		add_label_entry($OP_TABLE5, "Trash boxes", 'trash_boxes')
		add_label_entry($OP_TABLE5, "Calibrate on startup", 'calibrate')
		add_label_entry($OP_TABLE5, "Calibrate count", 'calibratecount')
		add_label_entry($OP_TABLE5, "Auto Bundle Vials", 'auto_bundle_vials')
		add_label_entry($OP_TABLE5, "Auto repair bent lockpicks", 'auto_repair_bent_lockpicks')
		add_label_entry($OP_TABLE5, "Number of times to check for traps", 'number_of_times_to_check_for_traps')
		add_label_entry($OP_TABLE6, "Light (205)", 'always_use_205')
		add_label_entry($OP_TABLE6, "Presence (402)", 'always_use_402')
		add_label_entry($OP_TABLE6, "Lock Pick Enhancement (403)", 'always_use_403')
		add_label_entry($OP_TABLE6, "Disarm Enhancement (404)", 'always_use_404')
		add_label_entry($OP_TABLE6, "Unlock (407)", 'always_use_407')
		add_label_entry($OP_TABLE6, "Haste (506)", 'always_use_506')
		add_label_entry($OP_TABLE6, "Self Control (613)", 'always_use_613')
		add_label_entry($OP_TABLE6, "Song of Luck (1006)", 'always_use_1006')
		add_label_entry($OP_TABLE7, "Rest at Percent", 'rest_percent')
		add_label_entry($OP_TABLE7, "Pick at Percent", 'pick_percent')
		add_label_entry($OP_TABLE8, "Ready", 'ready')
		add_label_entry($OP_TABLE8, "Can't Open Box", 'cant_open_box')
		add_label_entry($OP_TABLE8, "Scarab Safe", 'scarab_safe')
		add_label_entry($OP_TABLE9, "Phase (704)", 'always_use_704')
		add_label_entry($OP_TABLE9, "Number of 416 casts", 'number_of_416_casts')
		add_label_entry($OP_TABLE9, "Only disarm safe", 'only_disarm_safe')
	}

	def self.add_checkbox(table, x_pos, label, variable, default = false)
		size = $OP_TABLE_SIZE[table] || 0
		checkbox = Gtk::CheckButton.new label
		value = UserVars.tpick[variable].nil? ? default : UserVars.tpick[variable]
		checkbox.set_active(value)
		table.attach(checkbox, x_pos, x_pos + 1, size, size + 1)
		$OP_ENTRY[variable] = checkbox
		$OP_TABLE_SIZE[table] += 1 if x_pos == 1
	end
        
	Gtk.queue {
		$OP_WINDOW.signal_connect("delete_event") {
			$OP_SETUP_COMPLETED = true
		}
	}
        
	Gtk.queue {
		$OP_TOOLTIPS = Gtk::Tooltips.new
		$OP_TOOLTIPS.enable

		label = Gtk::Label.new
		label.set_markup("Enter the name of your lockpicks above.  If you don't have a particular lockpick use the next best lockpick.\nFor example if you don't have a steel lockpick then put the name of your gold lockpick in both the steel and gold lockpick variables.")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$OP_TABLE1.attach(align, 1, 2, 8, 9)

		label = Gtk::Label.new
		label.set_markup("Enter the name of your lockpicks above.  If you don't have a particular lockpick use the next best lockpick.\nFor example if you don't have a steel lockpick then put the name of your gold lockpick in both the steel and gold lockpick variables.")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$OP_TABLE2.attach(align, 1, 2, 8, 9)

		label = Gtk::Label.new
		label.set_markup("Enter the names of your containers where the above items can be found.\n<b>Broken Lockpick Container:</b>  Container where script will store your broken lockpicks.\n<b>Locksmith's Container:</b>  Container where putty and cotton balls are found.")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$OP_TABLE3.attach(align, 1, 2, 8, 9)

		label = Gtk::Label.new
		label.set_markup("<b>Scale Trap Weapon:</b>  Name of weapon you use for disarming scale traps.\n<b>Trap Roll:</b>  Determines what difficulty boxes you want to attempt.\nSet to 0 to never try anything higher than your total disarm skill + lore bonus.\nSetting to 10 would attempt traps 10 points higher than your disarm skill + lore bonus.\nSetting to -10 would only attempt traps that are a maximum of 10 points lower than your disarm skill + lore bonus.\nSet this value to whatever number you want. A value of 1000 would attempt to disarm all traps.\nScript will always use 404 if it determines you need the spell to disarm a trap.\n<b>Lock Roll:</b>  Maximum roll allowed before moving to a higher lockpick.\nExample a roll of 70 or higher is needed to pick a lock with a copper lockpick\nIf this value was set to 80 the script would attempt to pick the lock\nIf this value was set to 50 the script would instead check to see if you could pick the lock with a steel lockpick with a roll of 50 or less\n<b>Vaalin Lock Roll:</b>  Same as above but just for vaalin picks if you want to attempt to pick locks with a higher needed roll than other lockpicks.\n<b>This number should be equal or higher than Lock Roll.</b>")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$OP_TABLE4.attach(align, 1, 2, 8, 9)

		label = Gtk::Label.new
		label.set_markup("<b>Trick:</b>  Trick to use when picking locks. Enter: spin, twist, turn, twirl, toss, bend or flip.  Enter <b>pick</b> if you don't want to use a trick.\n<b>Log:</b>  Enter <b>yes</b> to display a summary of all loot found when done.\n<b>Trash boxes:</b>  Enter <b>yes</b> to dispose of empty boxes if possible, <b>no</b> will drop them on the ground.\n<b>Calibrate on startup:</b>  Enter <b>yes</b> to calibrate your calipers whenever the script is started and you are measuring locks, <b>no</b> to skip calibrating or you have less than 40 ranks of lock mastery.\n<b>Calibrate Count:</b>  Will calibrate your calipers every time you pick this many boxes.\n<b>Auto Bundle Vials:</b> Enter <b>yes</b> to have script bundle vials you get from disarming traps into your locksmith's container.\n<b>Auto repair bent lockpicks:</b>  Enter <b>yes</b> to have script automatically repair lockpicks after they have been bent. Only works if you have learned lmas repair.\n<b>Number of times to check for traps:</b>  How many times you want script to manually check for traps.")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$OP_TABLE5.attach(align, 1, 2, 8, 9)

		label = Gtk::Label.new
		label.set_markup("Enter <b>yes</b> for any spells you want to keep on while disarming/picking, <b>no</b> for any spells you don't want to cast.\nIf 403 and 404 are set to <b>no</b> the script will cast the spells when needed (after a failure or for a very high lock) and if you know the spell.\nSet 403 and 404 to <b>cancel</b> if you want these spells stopped when starting on a new box.\nIf <b>407</b> is set to <b>plate</b> the script will attempt to open plated boxes (except mithril or enruned) with 407 if you have no acid vials or wedges.\nIf <b>407</b> is set to <b>all</b> the script will attempt to open all boxes (except mithril and enruned) with 407.\nEnter <b>no</b> for <b>407</b> to skip using 407 on boxes.")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$OP_TABLE6.attach(align, 1, 2, 8, 9)

		label = Gtk::Label.new
		label.set_markup("<b>Rest at Percent:</b>  Script will pause when your mind reaches this amount or higher.  Enter <b>-1</b> to never rest.\n<b>Pick at Percent:</b>  Will start picking when your mind reaches this amount or lower.  Enter <b>100</b> to always pick.\nOnly for ground picking or picking your own boxes.\nUse the following amounts\nmust rest:  100\nnumbed:  90\nbecoming numbed:  75\nmuddled:  62\nclear:  50\nfresh and clear:  25\nclear as a bell:  0")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$OP_TABLE7.attach(align, 1, 2, 8, 9)

		label = Gtk::Label.new
		label.set_markup("Enter <b>nil</b> for any option where you don't want to speak.\n<b>Ready:</b>  What to say when ready to be handed boxes from another person. Example: <b>Ready.</b>\n<b>Can't Open Box:</b>  What to say when you can't open a box for another person. Example: <b>Sorry can't open this box.</b>\n<b>Scarab Safe:</b>  What to say when scarab is safe for other person to pick up. Example: <b>Scarab safe to pick up now.</b>")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$OP_TABLE8.attach(align, 1, 2, 8, 9)

		label = Gtk::Label.new
		label.set_markup("<b>Phase (704):</b>  Enter <b>yes</b> to use Phase (704) on each box to check for glyph traps, <b>no</b> to skip Phase.\n<b>Number of 416 casts:</b>  Number of times you want to check a box for traps using Piercing Gaze (416).\n<b>Only disarm safe:</b>  Some traps can be bypassed altogether when using 407 to open the box and some traps are always safe to use 408 on.\nHowever some traps have a chance of being set off when using 408. \nEnter <b>yes</b> here to skip boxes with traps that are not 100% safe, <b>no</b> to attempt disarming them with 408.\nSome traps are never safe to use 408 on and the script will always skip these boxes no matter what value you enter here.")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$OP_TABLE9.attach(align, 1, 2, 8, 9)

		$OP_WINDOW.show_all
	}
        
	$OP_SETUP_COMPLETED = false
	until($OP_SETUP_COMPLETED)
		sleep 1
	end
       
	UserVars.tpick ||= Hash.new
	$OP_ENTRY.keys.each { |key|
		if( $OP_ENTRY[key].class.to_s =~ /CheckButton/ )
			value = $OP_ENTRY[key].active?
			UserVars.tpick[key] = $OP_ENTRY[key].active?
		else
			if(key == 'wounded_eval')
				UserVars.tpick[key] = $OP_ENTRY[key].text
			else
				UserVars.tpick[key] = $OP_ENTRY[key].text.strip.downcase
			end
		end
	}
	UserVars.save()
        
	Gtk.queue {
		$OP_WINDOW.destroy
	}
}

pop_start = proc{
	$tpick_list_of_box_ids.each{ |box|
		current_box = box
		pop_boxes_begin.call
	}
	disk.call
}

pop_boxes_begin = proc{
	fput "get ##{current_box}"
	remaining_416_casts = UserVars.tpick["number_of_416_casts"].to_i
	stuff_to_do.call
	wait_until { checkright != nil }
	check_for_command = "glance"
	check_for_boxes.call
	wait_until { check_hands_status }
	if check_hands_status == "mithril or enruned"
		echo "Can't open this box because it is mithril or enruned."
		fput "drop ##{current_box}" if solo_or_other == "ground"
		where_to_stow_box.call if solo_or_other == "solo"
		box_opened = nil
	elsif check_hands_status == "empty"
		echo "No box was found in your hands."
		exit
	else
		if use_spell_704
			if !Spell[704].affordable?
				echo "Waiting for mana."
				wait_until { Spell[704].affordable? }
			end
			waitcastrt?
			fput "prep 704"
			fput "cast at ##{current_box}"
			while line = get
				if line =~ /resists the effects of your magic/
					echo "Box has a glyph trap and cannot be opened."
					fput "drop ##{current_box}" if solo_or_other == "ground"
					where_to_stow_box.call if solo_or_other == "solo"
					box_opened = nil
					break
				elsif line =~ /appears lighter|then stabilizes|but quickly returns to normal|Roundtime/
					echo "Box has no glyph trap. Checking for other traps."
					2.times { fput "drop #{checkright}" } if use_spell_704
					fput "get ##{current_box}" if use_spell_704 && solo_or_other != "ground"
					check_for_trap.call
					break				
				end
			end
		else
			echo "Checking for traps."
			fput "drop ##{current_box}" if solo_or_other == "ground"
			check_for_trap.call
		end
	end
}

where_to_stow_box = proc{
	if solo_or_other == "solo"
		if stow_in_disk
			fput "put ##{current_box} in #{checkname} disk"
		else
			fput "stow ##{current_box}"
		end
	end
}

cast_402 = proc{
	if !Spell[402].active?
		if !Spell[402].affordable?
			echo "Waiting for mana."
			wait_until { Spell[402].affordable? }
		end
		Spell[402].cast
	end
	waitcastrt?
}

cast_403 = proc{
	if !Spell[403].active?
		if !Spell[403].affordable?
			echo "Waiting for mana."
			wait_until { Spell[403].affordable? }
		end
		Spell[403].cast
	end
	waitcastrt?
}

cast_404 = proc{
	if !Spell[404].active?
		if !Spell[404].affordable?
			echo "Waiting for mana."
			wait_until { Spell[404].affordable? }
		end
		Spell[404].cast
	end
	waitcastrt?
}

check_for_trap = proc{
	cast_402.call
	cast_404.call
	current_trap_type = nil
	if !Spell[416].affordable?
		echo "Waiting for mana."
		wait_until { Spell[416].affordable? }
	end
	waitcastrt?
	fput "prep 416"
	fput "cast at ##{current_box}"
	while line = get
		if line =~ /Peering closely into the lock\, you spy.*scarab wedged into the lock mechanism\./
			current_trap_type = "scarab"
		elsif line =~ /You notice what appears to be a sharp sliver of metal nestled in a hole next to the lock plate\./
			current_trap_type = "needle"
		elsif line =~ /You notice a discolored oval ring around the outside of the.*which makes you suspicious\.\s+Your suspicions are confirmed when you look inside the keyhole and notice the spring\-loaded jaws pressed flush against the.*walls\./
			current_trap_type = "jaws"
		elsif line =~ /You see a tiny sphere imbedded in the lock mechanism\./
			current_trap_type = "sphere"
		elsif line =~ /You can see a small crystal imbedded in the locking mechanism\./
			current_trap_type = "crystal"
		elsif line =~ /You see a cord stretched between the lid and case\./
			current_trap_type = "scales"
		elsif line =~ /Peering through the .*\, you notice that the lock casing is coated with a rough\, grainy substance\, and a small bladder is wedged between the tumblers of the lock\./
			current_trap_type = "sulphur"
		elsif line =~ /Looking closely into the keyhole of the lock\, you spy a small vial of liquid and a tiny hammer device which seems poised to shatter it if the lock is tampered with\./
			current_trap_type = "cloud"
		elsif line =~ /You notice what appears to be a tiny vial placed just past the tumblers of the lock mechanism\.\s+It appears that any tampering with the lock mechanism will cause the tumblers to crush the vial\./
			current_trap_type = "acid vial"
		elsif line =~ /Peering through the .*\, you notice that the hinges have some springs incorporated into the design in an unusual fashion\./
			current_trap_type = "springs"
		elsif line =~ /Looking closely into the keyhole of the lock\, you spy a small vial of fire\-red liquid and a tiny hammer device which seems poised to shatter it if the lock is tampered with\./
			current_trap_type = "fire vial"
		elsif line =~ /You see a thin tube extending from the lock mechanism down into the .*\.\s+The tube appears to be filled with a greenish powder\./
			current_trap_type = "spores"
		elsif line =~ /There appears to be a plate over the lock\, sealing it and preventing any access to the tumblers\./
			current_trap_type = "plate"
		elsif line =~ /Near the lock mechanism\, you notice a pair of small metal rods a hair\'s width from rubbing together\./
			current_trap_type = "rods"
		elsif line =~ /The inside chamber is lined with some unidentifiable substance\./
			current_trap_type = "boomer"
		elsif line =~ /You gaze at the.*but your vision is obscured\./
			current_trap_type = "check again"
		elsif line =~ /Suddenly a dark splotch erupts from the lock mechanism and envelops you\!  Time seems to slow down and almost stop\.\.\./
			current_trap_type = "glyph"
		elsif line =~ /Roundtime/
			break
		end
	end
	if current_trap_type != "check again" && current_trap_type != nil
		echo "Found a #{current_trap_type} trap."
	end
	if current_trap_type == "check again"
		echo "Failed detecting a trap, trying again."
		check_for_trap.call
	elsif current_trap_type == "needle" || current_trap_type == "jaws" || current_trap_type == "plate"
		echo "Trap is safe to skip disarming."
		pop_open_box.call
	elsif current_trap_type == "crystal" || current_trap_type == "springs"
		echo "Trap is safe to use 408 on. Must be disarmed before popping."
		disarm_trap.call
	elsif current_trap_type == "scarab" || current_trap_type == "sphere" || current_trap_type == "scales" || current_trap_type == "acid vial" || current_trap_type == "fire vial" || current_trap_type == "spores" || current_trap_type == "boomer" || current_trap_type == "cloud" || current_trap_type == "rods"
		echo "408 might set off trap. Must be disarmed before popping."
		if UserVars.tpick["only_disarm_safe"] == "yes"
			echo "Skipping box due to tpick setting Only disarm safe is set to yes."
			where_to_stow_box.call
			box_opened = nil
		else
			disarm_trap.call
		end
	elsif current_trap_type == "sulphur"
		echo "Skipping box because 408 will set this trap off."
		where_to_stow_box.call
		box_opened = nil
	elsif current_trap_type == "glyph"
		echo "The box had a glyph trap on it. Taking you back to the room you started in."
		while checkroom =~ /Temporal Rift/
			move 'e'
			sleep 0.1
		end
		sleep 0.5
		start_script "go2", [starting_room]
		wait_while{ running?('go2') }
		echo "This box has a glyph trap and cannot be opened."
		where_to_stow_box.call
		box_opened = nil
	elsif current_trap_type == nil
		echo "No trap found."
		remaining_416_casts -= 1
		if remaining_416_casts < 1
			pop_open_box.call
		else
			echo "416 casts remaining: #{remaining_416_casts}."
			check_for_trap.call
		end
	end
}

fused_lock_disarm = proc{
	if Char.prof == 'Rogue'
		echo "Going to try wedging this box open."
		wedge_lock.call
	elsif Char.prof != 'Rogue' and !Spell[407].known?
		echo "Can't open this box."
		if solo_or_other == "solo"
			where_to_stow_box.call
		elsif solo_or_other == "other"
			fput "'#{UserVars.tpick["cant_open_box"]}" if UserVars.tpick["cant_open_box"] != "nil"
			open_others.call
		elsif solo_or_other == "ground"
			cant_open_plated_box_count += 1
			box_opened = nil
		end
	elsif Char.prof != 'Rogue' and Spell[407].known?
		fput "get ##{current_box}" if solo_or_other == "ground"
		fput "glance"
		while line = get
			if line =~ /You glance down to see (.*) in your right hand/i
				current_box_name = $1
				break
			end
		end
		echo "Going to try popping this box."
		cast_407.call
	end
}

pop_open_box = proc{
	box_is_open = nil
	echo "Popping box."
	loop{
		cast_403.call
		waitrt?
		waitcastrt?
		if !Spell[407].affordable?
			echo "Waiting for mana."
			wait_until { Spell[407].affordable? }
		end
		fput "prep 407"
		fput "cast at ##{current_box}"
		while line = get
			if line =~ /The.*vibrates slightly but nothing else happens\.|Suddenly\, part of the.*face breaks away and a pair of gleaming jaws snap shut before the lockplate\!\s+Good thing your hand wasn\'t there\!|Roundtime/
				break
			elsif line =~ /You hear a soft click from the.*and it suddenly flies open\.|But the.*is already open\./
				box_is_open = true
				break
			end
		end
		break if box_is_open
	}
	open_solo.call if solo_or_other != "ground"
}

disarm_trap = proc{
	box_is_disarmed = nil
	loop{
		cast_402.call
		cast_404.call
		waitrt?
		waitcastrt?
		if !Spell[408].affordable?
			echo "Waiting for mana."
			wait_until { Spell[408].affordable? }
		end
		waitcastrt?
		fput "prep 408"
		fput "cast at ##{current_box}"
		while line = get
			if line =~ /Now to isolate the offending mechanism and disable it\.\.\.The.*vibrates slightly but nothing else happens\.|You begin to probe the.*for unusual mechanisms\.\.\.The.*vibrates slightly but nothing else happens\./
				echo "Couldn't disarm trap. Tryin again."
				break
			elsif line =~ /Now to isolate the offending mechanism and disable it\.\.\.Your heart skips a beat as you hear a small sizzle from the.*keyhole\..*You begin to jump back\, but not in time as the entire.*explodes in a deafening\, fiery detonation\!/
				echo "The trap was set off! Script is now exiting."
				exit
			elsif line =~ /Now to isolate the offending mechanism and disable it\.\.\.The.*pulses once with a deep crimson light\!/
				box_is_disarmed = true
				echo "Box is disarmed."
				break
			end
		end
		break if box_is_disarmed
	}
	pop_open_box.call
}

fill_up_locksmith_container = proc{
	move 'out' if checkpaths 'out'
	start_script 'go2', [ 'bank', '--disable-confirm' ]
	wait_while{ running?('go2') }
	fput "unhide" if hidden?
	fput "depo all"
	fput "withdraw 1000"
	start_script 'go2', [ Room[Room.current.find_nearest_by_tag('locksmith')], '--disable-confirm' ]
	wait_while{ running?('go2') }
	fput "order"
	while line = get
		if line =~ /\d+.*\s{2}(\d+).*locksmith\'s/
			order_number = $1
		elsif line =~ /(\d+).*locksmith\'s/
			order_number = $1
		end
		break if line =~ /You can APPRAISE/
	end
	stow_right.call
	stow_left.call
	wait_until { checkleft == nil }
	wait_until { checkright == nil }
	fput "remove my #{UserVars.tpick["locksmiths_container"]}"
	wait_until { checkright != nil }
	fput "order #{order_number}"
	fput "buy"
	wait_until { checkleft != nil }
	fput "bundle"
	trash_container = GameObj.loot.find { |trash| trash.name =~ trash_container }
	if trash_container == nil
		fput "drop my #{checkleft}"
	else
		fput "put my #{checkleft} in #{trash_container}"
		sleep 0.2
		if checkleft != nil
			fput "drop #{checkleft}"
		end
	end
	if putty_remaining < 50 || cotton_remaining < 50
		fput "order #{order_number}"
		fput "buy"
		wait_until { checkleft != nil }
		fput "bundle"
		trash_container = GameObj.loot.find { |trash| trash.name =~ trash_container }
		if trash_container == nil
			fput "drop my #{checkleft}"
		else
			fput "put my #{checkleft} in #{trash_container}"
			sleep 0.2
			if checkleft != nil
				fput "drop my #{checkleft}"
			end
		end
	end
	fput "wear my #{UserVars.tpick["locksmiths_container"]}"	
}


check_locksmiths_container = proc{
	action = proc { |server_string|
		if server_string =~ /lump of squishy white putty with about (\d+) pinch|(\d+) little ball|(\d+) vials? of liquid|you see a pinch of squishy white putty/
			if server_string =~ /you see a lump of squishy white putty with about (\d+) pinch/
				putty_remaining = $1.to_i
			elsif server_string =~ /you see a pinch of squishy white putty/
				putty_remaining = 1
			else 
				putty_remaining = 0
			end
			if server_string =~ /(\d+) little ball/
				cotton_remaining = $1.to_i
			else
				cotton_remaining = 0
			end
			if server_string =~ /(\d+) vials? of liquid/
				vials_remaining = $1.to_i
			else
				vials_remaining = 0
			end
			DownstreamHook.remove("#{script.name}_check_locksmiths_container")
			nil
		elsif server_string =~ / and /
			(putty_remaining = 0) unless (putty_remaining)
			(cotton_remaining = 0) unless (cotton_remaining)
			(vials_remaining = 0) unless (vials_remaining)
			DownstreamHook.remove("#{script.name}_check_locksmiths_container")
			server_string
		else
			server_string
		end
	}
		DownstreamHook.add("#{script.name}_check_locksmiths_container", action)
		silence_me
		if running? "sorter"
			kill_script "sorter"
			wait_until { !running? "sorter" }
			start_sorter = true
		end
		fput "look in my #{UserVars.tpick["locksmiths_container"]}"
		silence_me
}

do_relock_boxes = proc{
	waitrt?
	if solo_or_other == "ground"
		fput "get ##{current_box}"
	end
	fput "get my #{UserVars.tpick["vaalin"]} from my #{UserVars.tpick["lockpick_container"]}"
	fput "close ##{current_box}"
	fput "lm relock ##{current_box}"
	if solo_or_other == "ground"
		fput "drop ##{current_box}"
	end
	fput "put my #{UserVars.tpick["vaalin"]} in my #{UserVars.tpick["lockpick_container"]}"
}

cast_407 = proc{
	if current_box_name =~ /enruned|mithril/i
		echo "Can't open this plated box because it is mithril or enruned."
		if solo_or_other == "solo"
			where_to_stow_box.call
			stow_right.call
			stow_left.call
			sleep 0.1
		elsif solo_or_other == "other"
			fput "'#{UserVars.tpick["cant_open_box"]}" if UserVars.tpick["cant_open_box"] != "nil"
			open_others.call
		elsif solo_or_other == "ground"
			fput "drop ##{current_box}"
			cant_open_plated_box_count += 1
			box_opened = nil
		end
	else
		(waitrt?;waitcastrt?)
		(echo "Waiting for mana.";wait_until { checkmana >= 10 }) if checkmana < 10
		cast_403.call
		waitrt?
		waitcastrt?
		fput "prep 407"
		result = dothistimeout "cast my #{checkright}", 4, /vibrates slightly but nothing else happens.|(suddenly flies open.|is already open.)/i
		if result =~ /(suddenly flies open.|is already open.)/i
			if solo_or_other == "solo"
				open_solo.call
			elsif solo_or_other == "other"
				open_others.call
			elsif solo_or_other == "ground"
				fput "drop ##{current_box}"
			end
		elsif result =~ /vibrates slightly but nothing else happens./i
			cast_407.call
		elsif result.nil?
			cast_407.call
		end
	end
}

wedge_lock = proc{
	waitrt?
	fput "get ##{current_box}" if solo_or_other == "ground" && checkright == nil
	result = dothistimeout "get my wedge from my #{UserVars.tpick["wedge_container"]}", 4, /(You remove|You detach|You slip)|Get what\?/i
	if result =~ /(You remove|You detach|You slip)/i
		result = dothistimeout "lmaster wedge ##{current_box}", 5, /What do you expect to wedge it with|(suddenly splits away from the casing|Why bother)|You insert the tip/i
		if result =~ /What do you expect to wedge it with/i
			(waitrt?;fput "put my wedge in my #{UserVars.tpick["wedge_container"]}" if (checkleft =~ /wedge/i or checkright =~ /wedge/i;wedge_lock.call))
		elsif result =~ /(suddenly splits away from the casing|Why bother)/i
			(waitrt?;fput "put my wedge in my #{UserVars.tpick["wedge_container"]}" if (checkleft =~ /wedge/i or checkright =~ /wedge/i);open_solo.call if solo_or_other == "solo";open_others.call if solo_or_other == "other";fput "drop ##{current_box}" if solo_or_other == "ground")
		elsif result =~ /You insert the tip/i
			(waitrt?;fput "put my wedge in my #{UserVars.tpick["wedge_container"]}" if (checkleft =~ /wedge/i or checkright =~ /wedge/i);wedge_lock.call)
		elsif result.nil?
			(echo "Error in wedge_lock.";exit)
		end
	elsif result =~ /Get what\?/i and close_wedge_sack == nil
		(fput "open my #{UserVars.tpick["wedge_container"]}";close_wedge_sack = "yes";wedge_lock.call)
	elsif result =~ /Get what\?/i and close_wedge_sack == "yes"
		if UserVars.tpick["always_use_407"] != "plate" or !Spell[407].known?
			if solo_or_other == "other"
				fput "'#{UserVars.tpick["cant_open_box"]}" if UserVars.tpick["cant_open_box"] != "nil"
				open_others.call
			elsif solo_or_other == "ground"
				echo "Couldn't open this box."
				box_opened = nil
			elsif solo_or_other == "solo"
				echo "Couldn't open this box."
				where_to_stow_box.call
				stow_right.call
				stow_left.call
				sleep 0.1
			end
		else
			fput "glance"
			while line = get
				(current_box_name = $1;break) if line =~ /You glance down to see (.*) in your right hand/i
			end
			(echo "Couldn't find any wedges, going to try popping this box.";cast_407.call;break)
		end
	elsif result.nil?
		(echo "Error found in wedge lock.";exit)
	end
}

calibrate = proc{
	echo "Calibrating calipers."
	waitrt?
	if checkright != "calipers" && checkleft != "calipers"
		result = dothistimeout "get my calipers", 4, /(You remove|You detach|You slip)|Get what\?/i
		if result =~ /(You remove|You detach|You slip)/i
			nil
		elsif result =~ /Get what\?/i and close_calipers_sack == nil
			fput "open my #{UserVars.tpick["calipers_container"]}"
			close_calipers_sack = "yes"
			result = dothistimeout "get my calipers", 4, /(You remove|You detach|You slip)|Get what\?/i
			if result =~ /(You remove|You detach|You slip)/i
				nil
			elsif result =~ /Get what\?/i
				echo "Couldn't find your calipers."
				exit
			end
		elsif result.nil?
			echo "Error found in calibrate."
			exit
		end
	end
	result = dothistimeout "lmas calibrate my calipers", 7, /You\'re good\, but you\'re not that good\.|You should leave them alone.|Roundtime/i
	if result =~ /You\'re good\, but you\'re not that good\.|You should leave them alone./i
		waitrt?
		fput "put my calipers in my #{UserVars.tpick["calipers_container"]}"
	elsif result =~ /Roundtime/i
		waitrt?
		calibrate.call if can_use_calipers
	elsif result.nil?
		echo "Error in calibrate."
		exit
	end
}

check_for_boxes = proc {
	action = proc { |server_string|
		if server_string =~ /\s{6}.*(an?|the|some) |\s{2}.*(an?|the|some) |^You are currently wearing and carrying\:/
			if server_string =~ /(\s{6}.*(an?|the|some)|\s{2}.*(an?|the|some)).*exist="(\d+)".*(strongbox|box|chest|trunk|coffer)/
				$tpick_list_of_box_ids.push($4)
			end
			nil
		elsif server_string =~ /^\(\d+ items? displayed\.\)/
			DownstreamHook.remove("#{script.name}_check_for_boxes")
			$tpick_boxes_checked = true
			nil
		elsif server_string =~ /You glance down to see.*mithril|enruned.*/
			check_hands_status = "mithril or enruned"
			DownstreamHook.remove("#{script.name}_check_for_boxes")
			nil
		elsif server_string =~ /You glance down.*left hand.*/
			check_hands_status = "good"
			DownstreamHook.remove("#{script.name}_check_for_boxes")
			nil
		elsif server_string =~ /You glance down at your empty hands\./
			check_hands_status = "empty"
			DownstreamHook.remove("#{script.name}_check_for_boxes")
			nil
		else
			server_string
		end
	}
		DownstreamHook.add("#{script.name}_check_for_boxes", action)
		silence_me
		fput "#{check_for_command}"
		silence_me
}

cast_205 = proc{
	if checkmana < 5
		echo "Waiting for mana."
	end
	Spell[205].cast
}

cast_402 = proc{
	if Spell[402].known? && !Spell[402].active?
		until Spell[402].active?
			"Waiting for mana." if !Spell[402].affordable?
			Spell[402].cast
			sleep 0.2
		end
	end
}

cast_403 = proc{
	if Spell[403].known? && !Spell[403].active?
		until Spell[403].active?
			"Waiting for mana." if !Spell[403].affordable?
			Spell[403].cast
			sleep 0.2
		end
	end
}

cast_404 = proc{
	if Spell[404].known? && !Spell[404].active?
		until Spell[404].active?
			"Waiting for mana." if !Spell[404].affordable?
			Spell[404].cast
			sleep 0.2
		end
	end
}

cast_506 = proc{
	if Spell[506].known? && !Spell[506].active?
		until Spell[506].active?
		"Waiting for mana." if !Spell[506].affordable?
		Spell[506].cast
		sleep 0.2
		end
	end
}

cast_613 = proc{
	if Spell[613].known? && !Spell[613].active?
		until Spell[613].active?
			"Waiting for mana." if !Spell[613].affordable?
			Spell[613].cast
			sleep 0.2
		end
	end
}

cast_1006 = proc{
	if Spell[1006].known? && !Spell[1006].active?
		until Spell[1006].active?
		"Waiting for mana." if !Spell[1006].affordable?
		Spell[1006].cast
			sleep 0.2
		end
	end
}

stuff_to_do = proc{
	if UserVars.tpick["rest_percent"].to_i >= percentmind
		echo "Resting until mind reaches #{UserVars.tpick["pick_percent"]}%."
		wait_until { UserVars.tpick["pick_percent"].to_i >= percentmind }
	end
}


start_solo = proc{
	$tpick_list_of_box_ids.each{ |box|
		fput "get ##{box}"
		stuff_to_do.call
		second_trap_check = nil
		number_of_manual_trap_checks_remaining = UserVars.tpick["number_of_times_to_check_for_traps"].to_i
		manually_disarm_trap.call
	}
	disk.call
}

start_others = proc{
	waitfor "has accepted your offer" if checkright != nil
	fput "accept"
	while line = get
		if line =~ /^You accept ([a-zA-Z]+)\'s offer and are now holding.*\.$/i
			person = $1
			second_trap_check = nil
			number_of_manual_trap_checks_remaining = UserVars.tpick["number_of_times_to_check_for_traps"].to_i
			manually_disarm_trap.call
			break
		elsif line =~ /^([a-zA-Z]+) offers you (.*) (box|strongbox|coffer|chest|trunk).  Click ACCEPT to accept the offer or DECLINE to decline it.  The offer will expire in 30 seconds\.$/
			person = $1
			fput "accept"
			second_trap_check = nil
			number_of_manual_trap_checks_remaining = UserVars.tpick["number_of_times_to_check_for_traps"].to_i
			manually_disarm_trap.call
			break
		end
	end
}

start_ground = proc{
	GameObj.loot.each{|box|
		if box.type =~ /box/i
			box_opened = true
			current_box = box.id
			(echo "Resting until mind reaches #{UserVars.tpick["pick_percent"]}%.";wait_until { UserVars.tpick["pick_percent"].to_i >= percentmind }) if UserVars.tpick["rest_percent"].to_i >= percentmind
			waitrt?
			if popping
				pop_boxes_begin.call
			else
				second_trap_check = nil
				number_of_manual_trap_checks_remaining = UserVars.tpick["number_of_times_to_check_for_traps"].to_i
				manually_disarm_trap.call
			end
			if ground_loot
				if box_opened
					waitrt?
					cast_506.call if use_spell_506
					total_boxes_picked += 1
					fput "open ##{current_box}" unless popping
					(dothistimeout "look in ##{box.id}", 10, /In .*? you see|In the .*\:/i) if box.contents.nil?
					box.contents.each{ |item|
						waitrt?
						if item.name !~ /urglaes fang/ && item.name !~ /doomstone/
							fput "get #{item} from ##{current_box}"
						end
						waitrt?
						if item.name !~ /coins/i && UserVars.tpick["log"] == "yes"
							record_item_data.call
						end
						if item.name !~ /coins/i && item.name !~ /urglaes fang/ && item.name !~ /doomstone/
							if UserVars.tpick["auto_bundle_vials"] == "yes" && item.name =~ /vial/ && (GameObj.right_hand.name =~ /vial/ || GameObj.left_hand.name =~ /vial/)
								check_locksmiths_container.call
								wait_until { vials_remaining }
								start_script "sorter" if start_sorter
								if vials_remaining < 10
									if GameObj.right_hand.name =~ /vial/
										current_vial = GameObj.right_hand.id
									elsif GameObj.left_hand.name =~ /vial/
										current_vial = GameObj.left_hand.id
									end
									fput "stow ##{current_vial}"
									sleep 0.2
									stow_right.call
									stow_left.call
									wait_until { checkleft == nil }
									wait_until { checkright == nil }
									fput "remove my #{UserVars.tpick["locksmiths_container"]}"
									wait_until { checkright != nil }
									fput "get ##{current_vial}"
									wait_until { checkleft != nil }
									fput "bundle"
									fput "wear my #{UserVars.tpick["locksmiths_container"]}"
									wait_until { checkright == nil }			
								end
							else
								if item.type =~ /gem/ && gem_container
									fput "put #{item} in my #{gem_container}"
								else
									fput "stow #{item}"
								end
							end
						end
						waitrt?
					}
					if relock_boxes
						do_relock_boxes.call
					end
					garbage_check.call
				end
			else
				if popping
					nil
				else
					fput "open ##{current_box}" if box_opened
					fput "drop ##{current_box}" if GameObj.right_hand.id == current_box
				end
			end
		end
	}
	(echo "All done!";echo "Couldn't open #{cant_open_plated_box_count} box(es), which are still on the ground." if cant_open_plated_box_count > 0;exit)
}

disk = proc{
	stow_in_disk = true
	unless disk = GameObj.loot.find { |obj| obj.name =~ /#{Char.name} disk/ }
		echo "Waiting 5 seconds for disk"
		50.times { break if GameObj.loot.any? { |obj| obj.name =~ /#{Char.name} disk/ }; sleep 0.1 }
			disk = GameObj.loot.find { |obj| obj.name =~ /#{Char.name} disk/ }
		end
	(echo "No disk found.";exit) if disk == nil
	if disk and disk.contents.nil?
		dothistimeout "look in ##{disk.id}", 3, /In the|There is nothing in there\./
	end
	disk.contents.each{|item|
		if item.type =~ /box/i
			waitrt?
			if popping
				current_box = item.id
				pop_boxes_begin.call
			else
				fput "get ##{item.id}"
				second_trap_check = nil
				number_of_manual_trap_checks_remaining = UserVars.tpick["number_of_times_to_check_for_traps"].to_i
				manually_disarm_trap.call
			end
		end
	}
}

manually_disarm_trap = proc{
	if second_trap_check
		echo "Attempting to disarm trap."
	else
		echo "Checking for traps."
		need_403 = nil
		need_404 = nil
	end
	waitrt?
	fput "stop 403" if Spell[403].active? && UserVars.tpick["always_use_403"] == "cancel"
	fput "stop 404" if Spell[404].active? && UserVars.tpick["always_use_404"] == "cancel"
	cast_402.call if use_spell_402
	cast_404.call if (use_spell_404) || (need_404)
	cast_506.call if use_spell_506
	cast_613.call if use_spell_613
	cast_1006.call if use_spell_1006
	trap_difficulty = nil
	trap_cant_be_disarmed = nil
	(wait_until { GameObj.right_hand.id != nil};current_box = GameObj.right_hand.id) if solo_or_other != "ground"
	fput "disarm ##{current_box}"
	while line = get
		if line =~ /\(.*\-(\d+)\)\./
			trap_difficulty = $1.to_i
			disarm_skill_plus_lore = (disarm_skill + disarm_lore)
			total_trap_skill = (disarm_skill + disarm_lore + UserVars.tpick["trap_roll"].to_i)
			if second_trap_check == nil
				echo "Trap difficulty is: #{trap_difficulty}"
				echo "Your disarm skill is: #{disarm_skill}"
				echo "Your total disarm skill with lore is: #{disarm_skill_plus_lore}"
				echo "Highest trap you are willing to try is: #{total_trap_skill}"
			end
			if trap_difficulty > total_trap_skill
				trap_cant_be_disarmed = true
			elsif trap_difficulty > disarm_skill && Spell[404].known?
				if second_trap_check == nil
					echo "This trap looks tough, going to use Disarm Enhancement (404)."
				end
				need_404 = "yes"
			elsif trap_difficulty > disarm_skill && !Spell[404].known?
				trap_cant_be_disarmed = true
			end
#####Failed to disarm box
		elsif line =~ /Having discovered a trap on the.*(box|strongbox|chest|trunk|coffer) you begin to carefully attempt to disarm it\.\.\./
			current_trap_type = "Couldn't disarm trap, trying again."
#####Scarab information#####
		#Manual detection
		elsif line =~ /Peering closely into the lock\, you spy.*scarab wedged into the lock mechanism\./
			current_trap_type = "scarab"
		#Successful manual disarm
		elsif line =~ /You carefully nudge the scarab free of its prison without disturbing the lock too much\.\s+The scarab falls from the lock and onto the ground in front of you\./
			current_trap_type = "Scarab trap has been disarmed."
			break
		#Already manually disarmed
		elsif line =~ /The lock appears to be free of all obstructions\./
			current_trap_type = "Scarab trap has already been disarmed."
			break
		#Already disarmed with 408
		elsif line =~ /Looking closely at the lock\, you spy.*scarab wedged into the lock mechanism\.\s+The scarab is surrounded by crimson glow\./
			current_trap_type = "Scarab trap has already been disarmed with 408."
			break
#####Needle information#####
		#Manual detection
		elsif line =~ /Hmmm\, you can see what appears to be a tiny hole next to the lock plate which doesn\'t seem to belong there\.\s+Looking closer you see a gleaming sliver of metal recessed in the hole\./
			current_trap_type = "needle"
		#Successful manual disarm
		elsif line =~ /Using a bit of putty from your.*\, you manage to block the tiny hole in the lock plate\.|Using a pair of metal grips\, you carefully remove .* from .* and cover the tip with a bit of putty\./
			current_trap_type = "Needle trap has been disarmed."
			break
		#Already manually disarmed
		elsif line =~ /You see a tiny hole next to the lock plate which has been completely plugged\.|You can see what appears to be a tiny hole next to the lock plate which doesn\'t seem to belong there\.  However\, nothing about it seems to indicate cause for alarm\.|You spot a shiny metal needle sticking out of a small hole next to the lockplate with some sort of dark paste on it\./
			current_trap_type = "Needle trap has already been disarmed."
			break
		#Already disarmed with 408
		elsif line =~ /You can see what appears to be a tiny hole next to the lock plate which doesn\'t belong there\.\s+An occasional glint of red winks at you from within the hole\./
			current_trap_type = "Needle trap has already been disarmed with 408."
			break
#####Jaws information#####
		#Manual detection
		elsif line =~ /You notice a discolored oval ring around the outside of the .*(box|strongbox|chest|trunk|coffer) which makes you suspicious\.\s+Your suspicions are confirmed when you look inside the keyhole and notice the spring\-loaded jaws pressed flush against the .*(box|strongbox|chest|trunk|coffer) walls\./
			current_trap_type = "jaws"
		#Successful manual disarm
		elsif line =~ /Using the pair of metal grips\, you manage to pull out the two pins that hold the upper and lower jaw pieces together\.\s+As the pins are removed\, the jaws suddenly close and warp under the tremendous strain applied by their arming mechanism\.|Using the pair of metal grips\, you manage to pull out the two pins that hold the upper and lower jaw pieces together\.|Using your metal grips\, you carefully remove a pair of small steel jaws from the .*(box|strongbox|chest|trunk|coffer) before piecing the apparatus back together\./
			current_trap_type = "Jaws trap has been disarmed."
			break
		#Already manually disarmed
		elsif line =~ /You notice a discolored oval ring around the outside of the .*(box|strongbox|chest|trunk|coffer) which makes you suspicious\.\s+Your suspicions are confirmed when you look inside the keyhole and notice the spring\-loaded jaws pressed flush against the.*walls\, but the pins that hold the jaws together have been pushed out\./
			current_trap_type = "Jaws trap has already been disarmed."
			break
		#Already disarmed with 408
		elsif line =~ /You see a pair of metal jaws clamped tightly before the lockplate on the.*(box|strongbox|chest|trunk|coffer)\./
			current_trap_type = "Jaws trap has already been disarmed with 408. Can't pick it."
			break
#####Sphere information#####
		#Manual detection
		elsif line =~ /Examining the .*(box|strongbox|chest|trunk|coffer)\, you locate.*sphere held in a metal bracket towards the back of the lock mechanism\..*It appears that were the tumblers to be activated\, the gem would be caught amongst them\./
			current_trap_type = "sphere"
		#Successful manual disarm
		elsif line =~ /With utmost care\, you slip your.*lockpick into the lock and gently nudge the.*Another moment of prodding\, and you are able to poke the gem free of its metal housing\, whereupon it falls down into the lock mechanism and out of sight\.|With utmost care\, you slip your.*lockpick into the lock and gently nudge the.*Tilting the .*(box|strongbox|chest|trunk|coffer) forward\, you knock the gem free of its metal housing and poke it out through the back of the lock\, allowing it to gently roll down the inside of the .*(box|strongbox|chest|trunk|coffer)\'s front wall\./
			current_trap_type = "Sphere trap has been disarmed."
			break
		#Already manually disarmed
		elsif line =~ /A thorough search of the area inside the tumblers reveals what appears to be a metal bracket of some sort\, although it seems to be empty now\./
			current_trap_type = "Sphere trap has already been disarmed."
			break
		#Already disarmed with 408
		elsif line =~ /The sphere is surrounded by a crimson glow\./
			current_trap_type = "Sphere trap has already been disarmed with 408."
			break
		#Need pick in hand messaging
		elsif line =~ /No matter how you try\, your fingers are just too big to get back there to the gem\.\s+You\'ll need some sort of thin\, rigid implement like a lockpick\./
			current_trap_type = "Sphere trap found, need to use lockpick to disarm."
		#Setting off trap manually
		elsif line =~ /Suddenly\, you hear a sound like shattered crystal and .* light flashes from the lock mechanism\!/
			current_trap_type = "Sphere trap has been set off."
			echo "Sphere trap has been set off! Exiting."
			exit
		#Trap has already been set off
		elsif line =~ /A thorough and careful search of the lock mechanism indicates that the entire .* is MANGLED\. It\'s probably not trapped anymore\./
			current_trap_type = "Sphere trap has already been set off."
			break
#####Crystal information#####
		#Manual detection
		elsif line =~ /Looking closely into the keyhole of the lock\, you spy.*crystal which seems imbedded in the locking mechanism\.\s+It looks as if opening the lock without the exact key could shatter it\./
			current_trap_type = "crystal"
		#Successful manual disarm
		elsif line =~ /With a little ingenuity you manage to grind down parts of the lock mechanism with your metal file\, so it won\'t come in contact with the crystal when you try to open it\./
			current_trap_type = "Crystal trap has been disarmed."
			break
		#Already manually disarmed
		elsif line =~ /Looking closely into the keyhole of the lock\, you spy.*crystal which seems imbedded in the locking mechanism\.\s+It looks as if opening the lock without the exact key could shatter it\, but parts of the mechanism have been ground away to avoid unwanted contact with the crystal\./
			current_trap_type = "Crystal trap has already been disarmed."
			break
		#Already disarmed with 408
		elsif line =~ /You can see.*crystal imbedded in the locking mechanism\, with a slight reddish glow about it\./
			current_trap_type = "Crystal trap has already been disarmed with 408."
			break
#####Scales information#####
		#Manual detection
		elsif line =~ /At first glance\, the.*(box|strongbox|chest|trunk|coffer) appears to be covered with hundreds of tiny metal scales\.\s+Closer examination reveals the \"scales\" to be razor sharp at the edges and possessing of a downward\-facing needlelike tip\.\s+However\, you should be able to avoid cutting yourself if you are careful\.|Despite heavy scrutiny\, you can see no way to pry off any of the scales\, nor any particular reason to\.\s+With a modicum of caution\, they should present no danger\.\s+Nothing else about the.*(box|strongbox|chest|trunk|coffer) suggests that it is trapped\./
			current_trap_type = "scales"
		#Successful manual disarm
		elsif line =~ /You gently slide your.*into the space under the lid and slice through the cord\.\s+That oughta do it\./
			current_trap_type = "Scales trap has been disarmed."
			break
		#Already manually disarmed
		elsif line =~ /Peering in through the crack between the lid and the casing\, you see what appears to be a thin cord dangling from the case\.\s+It looks to have been sliced through\./
			current_trap_type = "Scales trap has already been disarmed."
			break
		#Already disarmed with 408
		elsif line =~ /A crimson glow seeps between the lid and the casing of the .*(box|strongbox|chest|trunk|coffer)\./
			current_trap_type = "Scales trap has already been disarmed with 408."
			break
		#Need dagger in hand messaging
		elsif line =~ /You figure that if you had a dagger\, you could probably cut the cord\./
			current_trap_type = "Scales trap found, need to use dagger to disarm."
			break
#####Sulphur information#####
		#Manual detection
		elsif line =~ /Feeling around the inside of the lock\, you notice that the casing is coated with a rough\, grainy substance\.\s+You lean forward and peer between the walls of the casing\.\s+Examining the lock closely\, you notice a small bladder filled with a strange liquid wedged between the tumblers\.\s+With your face this close to the lock\, you pick up the faintest scent of sulphur\./

			current_trap_type = "sulphur"
		#Successful manual disarm
		elsif line =~ /You carefully use the tip of a small metal file to scrape away the rough\, grainy substance which lines the walls of the casing\.\s+After a few moments\, you feel comfortable with the small section you have cleaned\.\s+You take out a thin needle and carefully slide it between the walls of the casing\, taking great care not to touch them\.\s+As the tip of the needle punctures the small bladder\, a strange clear gel oozes forth from the hole\.\s+The gel gives off a strong odor of sulphur\.\s+As the air hits the gel\, it begins to harden and turn to dust\, blowing away in the wind as if it never existed\./
			current_trap_type = "Sulphur trap has been disarmed."
			break
		#Already manually disarmed
		elsif line =~ /Feeling around the inside of the lock\, you notice that the casing is coated with a rough\, grainy substance\.\s+A small section of the casing has been scraped clean of the strange substance\.\s+You lean forward and peer between the walls of the casing\.\s+Examining the lock closely\, you notice a deflated bladder wedged between the tumblers\.\s+There is a small hole in the bladder\, most likely from whatever ruptured it\.\s+The lock emanates a strong scent of sulphur\./
			current_trap_type = "Sulphur trap has already been disarmed."
			break
		#Already disarmed with 408
		#TRAP CANNOT BE DISARMED WITH 408
#####Cloud information#####
		#Manual detection
		elsif line =~ /Looking closely into the keyhole of the lock\, you spy a small vial of liquid and a tiny hammer device which seems poised to shatter it if the lock is tampered with\./
			current_trap_type = "cloud"
		#Successful manual disarm
		elsif line =~ /Using the metal grips from your.*\, you manage to reach in and grasp the post of the metal hammer\, and bend the weak metal out of striking range of the vial\.|Having rendered the hammer harmless\, you carefully remove a green\-tinted vial filled with thick acrid smoke from the .*(box|strongbox|chest|trunk|coffer)\./
			current_trap_type = "Cloud trap has been disarmed."
			break
		#Already manually disarmed
		elsif line =~ /Looking closely into the keyhole of the lock\, you spy a tiny hammer device which has been bent back slightly\.|Looking closely into the keyhole of the lock\, you spy a small vial of liquid and a tiny hammer device which has been bent from striking range of the vial\./
			current_trap_type = "Cloud trap has already been disarmed."
			break
		#Already disarmed with 408
		elsif line =~ /Looking closely into the keyhole of the lock\, you spy a small vial of liquid and a tiny hammer device which has a red glow about it\./
			current_trap_type = "Cloud trap has already been disarmed with 408."
			break
#####Acid vial information#####
		#Manual detection
		elsif line =~ /Peering closely into the lock\, you spy a tiny vial placed just past the tumblers of the lock mechanism\.\s+It would appear that any tampering with the lock mechanism would cause the tumblers to crush the vial and release whatever substance is inside\./
			current_trap_type = "acid vial"
		#Successful manual disarm
		elsif line =~ /You carefully push a small ball of cotton into the lock mechanism\, surrounding and protecting the small vial from anything that may shatter it\.|Using a pair of metal grips\, you carefully remove the padded clear glass vial from the .*(box|strongbox|chest|trunk|coffer)\./
			current_trap_type = "Acid vial trap has been disarmed."
			break
		#Already manually disarmed
		elsif line =~ /Peering closely into the lock\, you spy a tiny vial placed just past the tumblers of the lock mechanism\.\s+A small ball of cotton has been pushed up against the vial\, protecting it from anything that may shatter it\.|Looking closely at the lock\, you spy a small metal housing set just inside the lock mechanism\, but it appears empty\./
			current_trap_type = "Acid vial trap has already been disarmed."
			break
		#Already disarmed with 408
		elsif line =~ /You notice what appears to be a tiny vial placed just past the tumblers of the lock mechanism\.\s+A crimson glow surrounds the vial\.|Looking closely at the lock\, you spy a tiny vial set just inside the lock mechanism\.\s+The vial is surrounded by crimson glow\./
			current_trap_type = "Acid vial trap has already been disarmed with 408."
			break
		#Setting off trap manually
		elsif line =~ /You peer inside the lock and see that the tumblers have all been fused into a lump of useless metal/
			current_trap_type = "Acid vial trap has been set off."
			break
		#Trap has already been set off
		elsif line =~ /You peer inside the lock and see that the tumblers have been fused into a lump of useless metal./
			current_trap_type = "Acid vial trap has already been set off."
			break
#####Springs information#####
		#Manual detection
		elsif line =~ /After carefully examining the lock\, you move on to the hinges of the .*(box|strongbox|chest|trunk|coffer)\.\s+Just as you were to pass the.*(box|strongbox|chest|trunk|coffer) off as safe\, you notice what appears to be the ends of springs incorporated with the hinges\.\s+Seems rather odd to have.*(box|strongbox|chest|trunk|coffer) designed to spring open when it is unlocked\./
			current_trap_type = "springs"
		#Successful manual disarm
		elsif line =~ /With a little force applied to the springs\, you manage to pop them inside the.*(box|strongbox|chest|trunk|coffer)\, from within which comes the tinkle of breaking glass\, followed by a strong acrid smell\.|With a little force applied to the springs\, you manage to pop them inside.*(box|strongbox|chest|trunk|coffer)\, where they bounce around for a moment\.\s+You also hear something else rolling around in there\./
			current_trap_type = "Springs trap has been disarmed."
			break
		#Already manually disarmed
		#Same messaging as when no traps found.
		#Already disarmed with 408
		elsif line =~ /You spot a reddish glow about the hinges of the.*(box|strongbox|chest|trunk|coffer)\./
			current_trap_type = "Springs trap has already been disarmed with 408."
			break
#####Fire vial information#####
		#Manual detection
		elsif line =~ /Looking closely into the keyhole of the lock\, you spy a small vial of fire\-red liquid and a tiny hammer device which seems poised to shatter it if the lock is tampered with\./
			current_trap_type = "fire vial"
		#Successful manual disarm
		elsif line =~ /Using the metal grips from your.*\, you manage to reach in and grasp the post of the metal hammer\, and bend the weak metal out of striking range of the vial\.|Having rendered the hammer harmless\, you carefully remove a thick glass vial filled with murky red liquid from the.*(box|strongbox|chest|trunk|coffer)\./
			current_trap_type = "Fire vial trap has been disarmed."
			break
		#Already manually disarmed
		elsif line =~ /Looking closely into the keyhole of the lock\, you spy a tiny hammer device which has been bent back slightly\.|Looking closely into the keyhole of the lock\, you spy a small vial of fire\-red liquid and a tiny hammer device which has been bent from striking range of the vial\./
			current_trap_type = "Fire vial trap has already been disarmed."
			break
		#Already disarmed with 408 NEED MESSAGING
		#elsif line =~ //
		#	current_trap_type = "Fire vial trap has already been disarmed with 408."
		#	break
#####Spores information#####
		#Manual detection
		elsif line =~ /Peering into the.*(box|strongbox|chest|trunk|coffer)\'s lock\, you see a small tube towards the bottom of the tumbler mechanism\.\s+The tube is capped with a thin membrane\, but it seems likely that the tumblers would tear it off while turning\./
			current_trap_type = "spores"
		#Successful manual disarm
		elsif line =~ /Taking a lump of putty from your.*\, you carefully apply it to the end of the small tube\.\s+That should block whatever it\'s meant to deploy\./
			current_trap_type = "Spores trap has been disarmed."
			break
		#Already manually disarmed
		elsif line =~ /Peering into the.*(box|strongbox|chest|trunk|coffer)\'s lock\, you see a small tube towards the bottom of the tumbler mechanism\.\s+It appears as though the tube has been plugged with something\./
			current_trap_type = "Spores trap has already been disarmed."
			break
		#Already disarmed with 408
		elsif line =~ /You see a thin tube extending from the lock mechanism down into the.*(box|strongbox|chest|trunk|coffer)\.\s+The end of the tube is surrounded by a crimson glow\.|Peering into the.*(box|strongbox|chest|trunk|coffer)\'s lock\, you see a small tube towards the bottom of the tumbler mechanism\.\s+A crimson glow surrounds the mouth of the tube\./
			current_trap_type = "Spores trap has already been disarmed with 408."
			break
		#Trap has already been set off
		elsif line =~ /Peering into the (box|strongbox|chest|trunk|coffer)\'s lock\, you see a small tube towards the bottom of the tumbler mechanism\. It appears as though the tube used to be covered with a thin membrane\, but it has torn mostly away\, and greyish-green powder covers the area around it\./
			current_trap_type = "Spores trap has already been set off."
			break
#####Plate information#####
		#Manual detection
		elsif line =~ /There appears to be a plate over the lock\, sealing it and preventing any access to the tumblers\.|Gonna chew through it/

			current_trap_type = "plate"
		#Successful manual disarm
		elsif line =~ /You carefully pour the contents of.*onto the .*(box|strongbox|chest|trunk|coffer) where you think the keyhole ought to be\.\s+.*\, the metal plate covering the lock begins to melt away\./
			current_trap_type = "Plate trap has been disarmed."
			break
		#Already manually disarmed
		elsif line =~ /You see a metal plate covering the lock plate\, but it appears to have been melted through\, granting sufficient access to the lock to attempt picking it./
			current_trap_type = "Plate trap has already been disarmed."
			break
		#Already disarmed with 408
		#Trap can't be disarmed with 408
#####Glyph information#####
		#Manual detection
		elsif line =~ /You notice some spiderweb\-like scratches on the lock plate which seem\, after some bit of scrutiny\, too organized to be just wear and tear \-\- it might be some type of glyph spell\./
			current_trap_type = "glyph"
		#Successful manual disarm
		elsif line =~ /Knowing how delicate magical glyphs can be\, you scrape some extra lines into the markings hoping to alter their meaning and defeat the spell they may hold\./
			current_trap_type = "Glyph trap has been disarmed."
			break
		#Already manually disarmed
		elsif line =~ /You notice some spiderweb\-like scratches on the lock plate which seem\, after some bit of scrutiny\, too organized to be just wear and tear \-\- it might be some type of glyph spell\, but some of the markings have been altered\.\s+This may prevent any magical nature they have from manifesting itself\./
			current_trap_type = "Glyph trap has already been disarmed."
			break
		#Already disarmed with 408
		#Trap can't be disarmed with 408
#####Rods information#####
		#Manual detection
		elsif line =~ /Looking closely into the keyhole\, you notice a pair of small metal rods a hair\'s width from touching each other\.\s+Peering around the inside of the keyhole\, you can see that the lock would push the two rods together should the lock be tampered with\./
			current_trap_type = "rods"
		#Successful manual disarm
		elsif line =~ /With great care you take a pair of metal grips and bend the sensitive metal rods out of alignment\.\s+It looks as though they cannot be pressed together by the lock mechanism any more\./
			current_trap_type = "Rods trap has been disarmed."
			break
		#Already manually disarmed
		elsif line =~ /Looking closely into the keyhole\, you notice a pair of small metal rods that have been bent in opposite directions of each other\./
			current_trap_type = "Rods trap has already been disarmed."
			break
		#Already disarmed with 408
		elsif line =~ /Near the lock mechanism\, you notice a pair of small metal rods surrounded by a crimson glow\.|Looking closely into the keyhole\, you notice a pair of small metal rods that have a slight reddish glow about them\./
			current_trap_type = "Rods trap has already been disarmed with 408."
			break
#####Boomer information#####
		#Manual detection
		elsif line =~ /Carefully\, you feel around the lock and notice the inside chamber is coated with a strange white substance\.\s+From your experience you recognize this as a common.*detonation system for an explosive mixture that was used to treat the .*(box|strongbox|chest|trunk|coffer)\./
			current_trap_type = "boomer"
		#Successful manual disarm
		elsif line =~ /Using a bit of putty from your.*\, you cake a thin layer on the lock casing\, hopefully sufficient to prevent sparks when the metal arm strikes it\./
			current_trap_type = "Boomer trap has been disarmed."
			break
		#Already manually disarmed
		elsif line =~ /A thin layer of mud or putty has been dabbed on the connecting point of the striking arm and the white substance to prevent it from igniting the.*(box|strongbox|chest|trunk|coffer) when it is unlocked\./
			current_trap_type = "Boomer trap has already been disarmed."
			break
		#Already disarmed with 408
		elsif line =~ /A deep red glow surrounds the striking arm of the trap mechanism\.\s+You hope it will keep the arm from making contact with the explosive white substance\./
			current_trap_type = "Boomer trap has already been disarmed with 408."
			break
#####No trap found#####
		elsif line =~ /You discover no traps\./
			current_trap_type = "No trap found."
			break
#####Box is already open#####
		elsif line =~ /Um, but it\'s open/
			current_trap_type = "Box is already open."
			break
#####No putty#####
		elsif line =~ /You figure that if you had some sort of putty/
			echo "No putty to disarm this trap. Exiting."
			exit
#####Roundtime#####
		elsif line =~ /Roundtime/
			break
		end

	end	
	second_trap_check = true
	if (current_trap_type == "No trap found." || current_trap_type == "Scarab trap has already been disarmed." || current_trap_type == "Scarab trap has already been disarmed with 408." || current_trap_type == "Needle trap has been disarmed." || current_trap_type == "Needle trap has already been disarmed." || current_trap_type == "Needle trap has already been disarmed with 408." || current_trap_type == "Jaws trap has been disarmed." || current_trap_type == "Jaws trap has already been disarmed." || current_trap_type == "Sphere trap has been disarmed." || current_trap_type == "Sphere trap has already been disarmed." || current_trap_type == "Sphere trap has already been disarmed with 408." || current_trap_type == "Crystal trap has been disarmed." || current_trap_type == "Crystal trap has already been disarmed." || current_trap_type == "Crystal trap has already been disarmed with 408." || current_trap_type == "Scales trap has been disarmed." || current_trap_type == "Scales trap has already been disarmed." || current_trap_type == "Scales trap has already been disarmed with 408." || current_trap_type == "Sulphur trap has been disarmed." || current_trap_type == "Sulphur trap has already been disarmed." || current_trap_type == "Cloud trap has been disarmed." || current_trap_type == "Cloud trap has already been disarmed." || current_trap_type == "Cloud trap has already been disarmed with 408." || current_trap_type == "Acid vial trap has been disarmed." || current_trap_type == "Acid vial trap has already been disarmed." || current_trap_type == "Acid vial trap has already been disarmed with 408." || current_trap_type == "Springs trap has been disarmed." || current_trap_type == "Springs trap has already been disarmed with 408." || current_trap_type == "Fire vial trap has been disarmed." || current_trap_type == "Fire vial trap has already been disarmed." || current_trap_type == "Fire vial trap has already been disarmed with 408." || current_trap_type == "Spores trap has been disarmed." || current_trap_type == "Spores trap has already been disarmed." || current_trap_type == "Spores trap has already been disarmed with 408." || current_trap_type == "Plate trap has been disarmed." || current_trap_type == "Plate trap has already been disarmed." || current_trap_type == "Glyph trap has been disarmed." || current_trap_type == "Glyph trap has already been disarmed." || current_trap_type == "Rods trap has been disarmed." || current_trap_type == "Rods trap has already been disarmed." || current_trap_type == "Rods trap has already been disarmed with 408." || current_trap_type == "Boomer trap has been disarmed." || current_trap_type == "Boomer trap has already been disarmed." || current_trap_type == "Boomer trap has already been disarmed with 408.")
		echo "#{current_trap_type}"
		number_of_manual_trap_checks_remaining -= 1
		if current_trap_type == "No trap found." && number_of_manual_trap_checks_remaining > 0
			echo "Number of trap checks remaining: #{number_of_manual_trap_checks_remaining}"
			second_trap_check = nil
			manually_disarm_trap.call
		else
			waitrt?
			if UserVars.tpick["auto_bundle_vials"] == "yes" && (GameObj.right_hand.name =~ /vial/ || GameObj.left_hand.name =~ /vial/)
				check_locksmiths_container.call
				wait_until { vials_remaining }
				start_script "sorter" if start_sorter
				if vials_remaining < 10
					if GameObj.right_hand.name =~ /vial/
						current_vial = GameObj.right_hand.id
					elsif GameObj.left_hand.name =~ /vial/
						current_vial = GameObj.left_hand.id
					end
					fput "stow ##{current_vial}"
					if (solo_or_other == "solo" || solo_or_other == "other")
						fput "stow ##{current_box}"
					end
					sleep 0.2
					stow_right.call
					stow_left.call
					wait_until { checkleft == nil }
					wait_until { checkright == nil }
					fput "remove my #{UserVars.tpick["locksmiths_container"]}"
					wait_until { checkright != nil }
					fput "get ##{current_vial}"
					wait_until { checkleft != nil }
					fput "bundle"
					fput "wear my #{UserVars.tpick["locksmiths_container"]}"
					wait_until { checkright == nil }
					if (solo_or_other == "solo" || solo_or_other == "other")
						fput "get ##{current_box}"
						wait_until { checkright != nil }
					end				
				end
			end
			stow_left.call
			stow_right.call if solo_or_other == "ground"
			measure.call
		end
	elsif current_trap_type == "Couldn't disarm trap, trying again."
		echo "#{current_trap_type}"
		cast_404.call
		manually_disarm_trap.call
	elsif (current_trap_type == "Acid vial trap has been set off." || current_trap_type == "Acid vial trap has already been set off.")
		echo "#{current_trap_type}"
		echo "Lock has been fused."
		fused_lock_disarm.call
	elsif current_trap_type == "Box is already open."
		echo "#{current_trap_type}"
		if solo_or_other == "solo"
			open_solo.call
		elsif solo_or_other == "other"
			open_others.call
		elsif solo_or_other == "ground"
			nil
		end
	elsif current_trap_type == "Scarab trap has been disarmed."
		echo "#{current_trap_type}"
		scarab2.call
	elsif current_trap_type == "plate"
		echo "Found a #{current_trap_type} trap."
		plate.call
	elsif current_trap_type == "Jaws trap has already been disarmed with 408. Can't pick it."
		echo "#{current_trap_type}"
		fused_lock_disarm.call
	else
		if current_trap_type == "Scales trap found, need to use dagger to disarm." || current_trap_type == "Sphere trap found, need to use lockpick to disarm."
			echo "#{current_trap_type}"
		else
			echo "Found a #{current_trap_type} trap."
		end
		if trap_cant_be_disarmed
			echo "Trap difficulty is too high according to your settings. Can't open box."
			if solo_or_other == "solo"
				where_to_stow_box.call
			elsif solo_or_other == "other"
				fput "'#{UserVars.tpick["cant_open_box"]}" if UserVars.tpick["cant_open_box"] != "nil"
				open_others.call
			elsif solo_or_other == "ground"
				cant_open_plated_box_count += 1
			end
		else
			echo "Attempting to disarm trap." if current_trap_type != "scales" && second_trap_check == nil
			if current_trap_type == "scales"
				scale.call
			elsif current_trap_type == "sphere" || current_trap_type == "Sphere trap found, need to use lockpick to disarm."
				sphere_trap.call
			elsif current_trap_type == "scarab"
				scarab.call
			elsif current_trap_type == "Scales trap found, need to use dagger to disarm."
				scaledisarm.call
			elsif (current_trap_type == "needle" || current_trap_type == "jaws" || current_trap_type == "crystal" || current_trap_type == "sulphur" || current_trap_type == "cloud" || current_trap_type == "acid vial" || current_trap_type == "springs" || current_trap_type == "fire vial" || current_trap_type == "spores" || current_trap_type == "glyph" || current_trap_type == "rods" || current_trap_type == "boomer")
				manually_disarm_trap.call
			end
		end
	end
}
			
sphere_trap = proc{
	waitrt?
	cast_404.call if use_spell_404
	result = dothistimeout "get my #{UserVars.tpick["vaalin"]} from my #{UserVars.tpick["lockpick_container"]}", 4, /(You remove|You detach|You slip)|Get what\?/i
	if result =~ /(You remove|You detach|You slip)/i
		sleep 0.1
	elsif result =~ /Get what\?/i and close_lockpick_sack == nil
		(fput "open my #{UserVars.tpick["lockpick_container"]}";close_lockpick_sack = "yes";sphere_trap.call)
	elsif result =~ /Get what\?/i and close_lockpick_sack == "yes"
		(echo "Couldn't find your #{UserVars.tpick["vaalin"]}.";exit)
	elsif result.nil?
		(echo "Error found in gem trap.";exit)
	end
	cast_404.call if use_spell_404
	cast_506.call if use_spell_506
	cast_613.call if use_spell_613
	cast_1006.call if use_spell_1006
	result = dothistimeout "disarm ##{current_box}", 5, /(you are able to poke the gem free of its metal housing|you knock the gem free of its metal housing)|(You must be holding a lockpick to perform that trick.|You didn't mention what you want to pick the lock with.)/i
	if result =~ /(you are able to poke the gem free of its metal housing|you knock the gem free of its metal housing)/i
		(waitrt?;fput "put my #{UserVars.tpick["vaalin"]} in my #{UserVars.tpick["lockpick_container"]}";measure.call)
	elsif result =~ /(You must be holding a lockpick to perform that trick.|You didn't mention what you want to pick the lock with.)/i
		(echo "Couldn't find #{UserVars.tpick["vaalin"]}.";exit)
	elsif result.nil?
		waitrt?
		fput "put my #{UserVars.tpick["vaalin"]} in my #{UserVars.tpick["lockpick_container"]}"
		cast_404.call
		sphere_trap.call
	end
}

scale = proc{
	echo "Picking lock with vaalin pick."
	waitrt?
	cast_403.call if use_spell_403
	cast_404.call if need_404 == "yes"
	result = dothistimeout "get my #{UserVars.tpick["vaalin"]} from my #{UserVars.tpick["lockpick_container"]}", 4, /(You remove|You detach|You slip)|Get what\?/i
	if result =~ /(You remove|You detach|You slip)/i
		sleep 0.1
	elsif result =~ /Get what\?/i and close_lockpick_sack == nil
		(fput "open my #{UserVars.tpick["lockpick_container"]}";close_lockpick_sack = "yes";scale.call)
	elsif result =~ /Get what\?/i and close_lockpick_sack == "yes"
		(echo "Couldn't find your #{UserVars.tpick["vaalin"]}.";exit)
	elsif result.nil?
		(echo "Error found in scale.";exit)
	end
	cast_403.call if use_spell_403
	cast_506.call if use_spell_506
	result = dothistimeout "#{do_trick} ##{current_box}", 5, /(You struggle with the .*\.  As you do\, you get a sense that the .* has .* \(.* thief\-lingo difficulty ranking\)\.  Then\.\.\.CLICK\!  It opens\!|as the tumblers snap open|It opens|It does not appear to be locked)|(You are not able to|You carefully try to work it|but you get a feeling|Roundtime)|broken lockpick|(You must be holding a lockpick to perform that trick.|You didn't mention what you want to pick the lock with.)/i
	if result =~ /(You struggle with the .*\.  As you do\, you get a sense that the .* has .* \(.* thief\-lingo difficulty ranking\)\.  Then\.\.\.CLICK\!  It opens\!|as the tumblers snap open|It opens|It does not appear to be locked)/
		waitrt?
		fput "put my #{UserVars.tpick["vaalin"]} in my #{UserVars.tpick["lockpick_container"]}"
		scaledisarm.call
	elsif result =~ /(You are not able to|You carefully try to work it|but you get a feeling|Roundtime)/
		cast_403.call
		(waitrt?;fput "put my #{UserVars.tpick["vaalin"]} in my #{UserVars.tpick["lockpick_container"]}";scale.call)
	elsif result =~ /broken lockpick/
		(echo "#{UserVars.tpick["vaalin"]} is broken.";waitrt?;fput "put my #{UserVars.tpick["vaalin"]} in my #{UserVars.tpick["broken_lockpick_container"]}";exit)
	elsif result =~ /(You must be holding a lockpick to perform that trick.|You didn't mention what you want to pick the lock with.)/i
		(echo "Couldn't find #{UserVars.tpick["vaalin"]}.";waitrt?;exit)
	elsif result.nil?
		(echo "FIX ME PLEASE! Stuck in scale def.";exit)
	end
}

scaledisarm = proc{
	echo "Attempting to disarm trap."
	waitrt?
	cast_404.call if need_404 == "yes"
	result = dothistimeout "get my #{UserVars.tpick["scale_trap_weapon"]}", 4, /(You remove|You detach|You slip)|Get what\?/i
	if result =~ /(You remove|You detach|You slip)/i
		sleep 0.1
	elsif result =~ /Get what\?/i and close_scaleweapon_sack == nil
		(fput "open my #{UserVars.tpick["scale_weapon_container"]}";close_scaleweapon_sack = "yes";scaledisarm.call)
	elsif result =~ /Get what\?/i and close_scaleweapon_sack == "yes"
		(echo "Couldn't find your #{UserVars.tpick["scale_trap_weapon"]}.";exit)
	elsif result.nil?
		(echo "Error found in scale disarm.";exit)
	end
	cast_404.call if use_spell_404
	cast_506.call if use_spell_506
	cast_613.call if use_spell_613
	cast_1006.call if use_spell_1006
	result = dothistimeout "disarm ##{current_box}", 5, /slice through the cord/i
	if result =~ /slice through the cord/
		(waitrt?;fput "put my #{UserVars.tpick["scale_trap_weapon"]} in my #{UserVars.tpick["scale_weapon_container"]}";open_solo.call if solo_or_other == "solo";open_others.call if solo_or_other == "other";sleep 0.1 if solo_or_other == "ground")
	elsif result.nil?
		waitrt?
		fput "put my #{UserVars.tpick["scale_trap_weapon"]} in my #{UserVars.tpick["scale_weapon_container"]}"
		cast_404.call
		scaledisarm.call
	end
}

scarab = proc{
	waitrt?
	cast_404.call if need_404 == "yes" || use_spell_404
	cast_506.call if use_spell_506
	cast_613.call if use_spell_613
	cast_1006.call if use_spell_1006
	result = dothistimeout "disarm ##{current_box}", 5, /carefully nudge the scarab free/i
	if result =~ /carefully nudge the scarab free/
		scarab2.call
	elsif result.nil?
		cast_404.call
		scarab.call
	end
}

scarab2 = proc{
	echo "Disarming scarab."
	waitrt?
	cast_506.call if use_spell_506
	sleep 1
	fput "disarm scarab"
	if (solo_or_other == "solo") || (ground_loot)
		waitrt?
		fput "get scarab"
		fput "stow my scarab"
	elsif solo_or_other == "other"
		fput "'#{UserVars.tpick["scarab_safe"]}" if UserVars.tpick["scarab_safe"] != "nil"
	elsif solo_or_other == "ground" && ground_loot == nil
		fput "'#{UserVars.tpick["scarab_safe"]}" if UserVars.tpick["scarab_safe"] != "nil"
	end
	measure.call
}

plate = proc{
	echo "Disarming trap."
	waitrt?
	cast_506.call if use_spell_506
	result = dothistimeout "disarm ##{current_box}", 5, /the metal plate covering the lock begins to melt away|Gonna chew through it/i
	if result =~ /the metal plate covering the lock begins to melt away/i
		measure.call
	elsif result =~ /Gonna chew through it/i and Char.prof == 'Rogue'
		(echo "No vials found bundled in your locksmith's pouch, going to try wedging this box open.";wedge_lock.call)
	elsif result =~ /Gonna chew through it/i and Char.prof != 'Rogue' and (!Spell[407].known? or (UserVars.tpick["always_use_407"] != "plate" and UserVars.tpick["always_use_407"] != "all"))
		echo "Can't open this plated box."
		if solo_or_other == "solo"
			exit
		elsif solo_or_other == "other"
			(fput "'#{UserVars.tpick["cant_open_box"]}" if UserVars.tpick["cant_open_box"] != "nil";open_others.call)
		elsif solo_or_other == "ground"
			(cant_open_plated_box_count += 1;box_opened = nil)
		end
	elsif result =~ /Gonna chew through it/i and Char.prof != 'Rogue' and Spell[407].known? and UserVars.tpick["always_use_407"] == "plate"
		(fput "get ##{current_box}" if solo_or_other == "ground";fput "glance")
		while line = get
			(current_box_name = $1;break) if line =~ /You glance down to see (.*) in your right hand/i
		end
		(echo "Going to try popping this box.";cast_407.call)
	elsif result =~ /Gonna chew through it/i and Char.prof != 'Rogue' and Spell[407].known? and UserVars.tpick["always_use_407"] == "all"
		(fput "get ##{current_box}" if solo_or_other == "ground";fput "glance")
		while line = get
			(current_box_name = $1;break) if line =~ /You glance down to see (.*) in your right hand/i
		end
		(echo "Going to try popping this box.";cast_407.call)
	elsif result.nil?
		(echo "FIX ME PLEASE! Stuck in plate def. Might be out of vials.";exit)
	end
}

measure = proc{
	waitrt?
	cast_506.call if use_spell_506
	if always_use_vaalin
		needed_pick = UserVars.tpick["vaalin"]
		pick = needed_pick
		need_403 = "yes"
		pick2.call
	elsif UserVars.tpick["always_use_407"] == "all"
		(fput "get ##{current_box}" if solo_or_other == "ground")
		fput "glance"
		while line = get
			(current_box_name = $1;break) if line =~ /You glance down to see (.*) in your right hand/i
		end
		cast_407.call
	else
		waitrt?
		if Char.prof == 'Rogue'
			echo "Measuring lock."
			result = dothistimeout "get my calipers", 4, /(You remove|You detach|You slip)|Get what\?/i
			if result =~ /(You remove|You detach|You slip)/i
				sleep 0.1
			elsif result =~ /Get what\?/i and close_calipers_sack == nil
				(fput "open my #{UserVars.tpick["calipers_container"]}";close_calipers_sack = "yes";measure.call;break)
			elsif result =~ /Get what\?/i and close_calipers_sack == "yes"
				(echo "Couldn't find your calipers.";exit)
			elsif result.nil?
				(echo "Error found in measure while trying to get calipers.";exit)
			end
			fput "lmaster measure ##{current_box}"
		elsif Char.prof == 'Bard'
			echo "Loresinging to box to find out lock difficulty."
			if solo_or_other == "ground"
				fput "get ##{current_box}"
			end
			fput "loresing #{checkright} that I hold;let your purpose now be told"
		end
		while line = get
			(lock = lock_difficulty[0];break) if line =~ /a primitive lock/i
			(lock = lock_difficulty[1];break) if line =~ /a rudimentary lock/i
			(lock = lock_difficulty[2];break) if line =~ /an extremely easy lock/i
			(lock = lock_difficulty[3];break) if line =~ /a very easy lock/i
			(lock = lock_difficulty[4];break) if line =~ /an easy lock/i
			(lock = lock_difficulty[5];break) if line =~ /a very basic lock/i
			(lock = lock_difficulty[6];break) if line =~ /a fairly easy lock/i
			(lock = lock_difficulty[7];break) if line =~ /a simple lock/i
			(lock = lock_difficulty[8];break) if line =~ /a fairly simple lock/i
			(lock = lock_difficulty[9];break) if line =~ /a fairly plain lock/i
			(lock = lock_difficulty[10];break) if line =~ /a moderately well-crafted lock/i
			(lock = lock_difficulty[11];break) if line =~ /a well-crafted lock/i
			(lock = lock_difficulty[12];break) if line =~ /a tricky lock/i
			(lock = lock_difficulty[13];break) if line =~ /a somewhat difficult lock/i
			(lock = lock_difficulty[14];break) if line =~ /a moderately difficult lock/i
			(lock = lock_difficulty[15];break) if line =~ /a very well-crafted lock/i
			(lock = lock_difficulty[16];break) if line =~ /a difficult lock/i
			(lock = lock_difficulty[17];break) if line =~ /an extremely well-crafted lock/i
			(lock = lock_difficulty[18];break) if line =~ /a very difficult lock/i
			(lock = lock_difficulty[19];break) if line =~ /a fairly complicated lock/i
			(lock = lock_difficulty[20];break) if line =~ /an intricate lock/i
			(lock = lock_difficulty[21];break) if line =~ /an amazingly well-crafted lock/i
			(lock = lock_difficulty[22];break) if line =~ /a very complex lock/i
			(lock = lock_difficulty[23];break) if line =~ /an impressively complicated lock/i
			(lock = lock_difficulty[24];break) if line =~ /an amazingly intricate lock/i
			(lock = lock_difficulty[25];break) if line =~ /an extremely difficult lock/i
			(lock = lock_difficulty[26];break) if line =~ /an extremely complex lock/i
			(lock = lock_difficulty[27];break) if line =~ /a masterfully well-crafted lock/i
			(lock = lock_difficulty[28];break) if line =~ /an amazingly complicated lock/i
			(lock = lock_difficulty[29];break) if line =~ /an astoundingly complex lock/i
			(lock = lock_difficulty[30];break) if line =~ /an incredibly intricate lock/i
			(lock = lock_difficulty[31];break) if line =~ /an absurdly well-crafted lock/i
			(lock = lock_difficulty[32];break) if line =~ /an exceedingly complex lock/i
			(lock = lock_difficulty[33];break) if line =~ /an absurdly difficult lock/i
			(lock = lock_difficulty[34];break) if line =~ /an unbelievably complicated lock/i
			(lock = lock_difficulty[35];break) if line =~ /a masterfully intricate lock/i
			(lock = lock_difficulty[36];break) if line =~ /an absurdly complex lock/i
			(lock = lock_difficulty[37];break) if line =~ /an impossibly complex lock/i
			(lock = "not locked";break) if line =~ /has already been unlocked/i
		end
		waitrt?
		if Char.prof == 'Rogue'
			fput "put my calipers in my #{UserVars.tpick["calipers_container"]}" if (checkleft =~ /calipers/i or checkright =~ /calipers/i)
		elsif Char.prof == 'Bard' && solo_or_other == "ground"
			fput "drop ##{current_box}"
		end
		(number = 0;needed_pick = nil)
		if lock == "not locked"
			needed_pick = UserVars.tpick["copper"]
			pick2.call
		else
			total_pick_skill = (pick_skill + pick_lore) * 2.50
			if lock > (total_pick_skill + UserVars.tpick["vaalin_lock_roll"].to_i)
				(echo "Can't pick this lock, going to try to wedge it open.";wedge_lock.call)
			else
				total_pick_skill = (pick_skill) * 2.50
				if lock > (total_pick_skill + UserVars.tpick["lock_roll"].to_i)
					needed_pick = UserVars.tpick["vaalin"]
					pick = needed_pick
					need_403 = "yes"
					pick2.call
				else
					pick_mod.each do |i|
						if (pick_skill) * 2.50 - lock + UserVars.tpick["lock_roll"].to_i < 100
							needed_pick = UserVars.tpick["vaalin"]
							need_403 = "yes"
						else
							total_pick_skill = (pick_skill) * i
							if total_pick_skill - lock + UserVars.tpick["lock_roll"].to_i < 100
								number = number + 1
							elsif
								if number == 0
									needed_pick = UserVars.tpick["copper"]
								elsif number == 1
									needed_pick = UserVars.tpick["steel"]
								elsif number == 2
									needed_pick = UserVars.tpick["gold"]
								elsif number == 3
									needed_pick = UserVars.tpick["silver"]
								elsif number == 4
									needed_pick = UserVars.tpick["mithril"]
								elsif number == 5
									needed_pick = UserVars.tpick["ora"]
								elsif number == 6
									needed_pick = UserVars.tpick["glaes"]
								elsif number == 7
									needed_pick = UserVars.tpick["laje"]
								elsif number == 8
									needed_pick = UserVars.tpick["vultite"]
								elsif number == 9
									needed_pick = UserVars.tpick["rolaren"]
								elsif number == 10
									needed_pick = UserVars.tpick["veniom"]
								elsif number == 11
									needed_pick = UserVars.tpick["invar"]
								elsif number == 12
									needed_pick = UserVars.tpick["alum"]
								elsif number == 13
									needed_pick = UserVars.tpick["golvern"]
								elsif number == 14
									needed_pick = UserVars.tpick["kelyn"]
								elsif number == 15
									needed_pick = UserVars.tpick["vaalin"]
								end
							end
						end
					end
					(pick = needed_pick;pick2.call)
				end
			end
		end
	end
}

pick2 = proc{
	waitrt?
	result = dothistimeout "get my #{pick} from my #{UserVars.tpick["lockpick_container"]}", 4, /(You remove|You detach|You slip)|Get what\?/i
	if result =~ /(You remove|You detach|You slip)/i
		pick3.call
	elsif result =~ /Get what\?/i and close_lockpick_sack == nil
		(fput "open my #{UserVars.tpick["lockpick_container"]}";close_lockpick_sack = "yes";pick2.call)
	elsif result =~ /Get what\?/i and close_lockpick_sack == "yes"
		(echo "Couldn't find #{pick}.";waitrt?;nextpick.call)
	elsif result.nil?
		(echo "Error found in pick2.";exit)
	end
}

pick3 = proc{
	echo "Attempting to pick lock."
	waitrt?
	cast_506.call if use_spell_506
	need_403 == "yes"
	cast_403.call if need_403 == "yes" || use_spell_403
	result = dothistimeout "#{do_trick} ##{current_box}", 5, /(You struggle with the .*\.  As you do\, you get a sense that the .* has .* \(.* thief\-lingo difficulty ranking\)\.  Then\.\.\.CLICK\!  It opens\!|It opens|as the tumblers snap open|It does not appear to be locked|already been unlocked)|(fumbling attempt|bit more luck|within your abilities|you get a sense that)|(You broke your lockpick in the attempt|you realize you are using a broken lockpick|You carefully try to work it free but end up snapping off the tip)|(You are not able to pick|You carefully try to work it free but end up bending the tip|You carefully try to work it free\, but it may have been weakened by the stress\.)|(You must be holding a lockpick to perform that trick.|You didn't mention what you want to pick the lock with.)/i
	if result =~ /(You struggle with the .*\.  As you do\, you get a sense that the .* has .* \(.* thief\-lingo difficulty ranking\)\.  Then\.\.\.CLICK\!  It opens\!|It opens|as the tumblers snap open|It does not appear to be locked|already been unlocked)/i
		calibrate_count += 1
		waitrt?
		fput "put my #{pick} in my #{UserVars.tpick["lockpick_container"]}"
		if result =~ /You struggle with the .*\.  As you do\, you get a sense that the .* has .* \(.* thief\-lingo difficulty ranking\)\.  Then\.\.\.CLICK\!  It opens\!|It opens|as the tumblers snap open/i && calibrate_count >= UserVars.tpick["calibratecount"].to_i
			if can_use_calipers
				calibrate.call unless popping
			end
			calibrate_count = 0
		end
		if solo_or_other == "solo"
			open_solo.call
		elsif solo_or_other == "other"
			open_others.call
		elsif solo_or_other == "ground"
			nil
		end
	elsif result =~ /(fumbling attempt|bit more luck|within your abilities|you get a sense that)/i
		if result =~ /You struggle with the .*\.  As you do\, you get a sense that the .* has .* \(.* thief\-lingo difficulty ranking\)\.  Then\.\.\.CLICK\!  It opens\!/
			waitrt?
			fput "put my #{pick} in my #{UserVars.tpick["lockpick_container"]}"
			if solo_or_other == "solo"
				open_solo.call
			elsif solo_or_other == "other"
				open_others.call
			elsif solo_or_other == "ground"
				sleep 0.1
			end	
		else
			waitrt?
			pick3.call
		end
	elsif result =~ /(You are not able to pick|You carefully try to work it free but end up bending the tip|You carefully try to work it free\, but it may have been weakened by the stress\.)/i
		waitrt?
		if result =~ /You carefully try to work it free but end up bending the tip|You carefully try to work it free\, but it may have been weakened by the stress\./ && UserVars.tpick["auto_repair_bent_lockpicks"] == "yes" && Char.prof =~ /Rogue/
			unless solo_or_other == "ground"
				until checkright == nil
					waitrt?
					fput "stow ##{current_box}"
					sleep 0.2
				end
			end
			fput "lmas repair my #{checkleft}"
			unless solo_or_other == "ground"
				until checkright != nil
					waitrt?
					fput "get ##{current_box}"
					sleep 0.2
				end
			end
		end
		fput "put my #{pick} in my #{UserVars.tpick["lockpick_container"]}"
		nextpick.call
	elsif result =~ /(You broke your lockpick in the attempt|you realize you are using a broken lockpick|You carefully try to work it free but end up snapping off the tip)/i
		(echo "#{pick} is broken.";waitrt?;broken_lockpick_stow.call)
	elsif result =~ /(You must be holding a lockpick to perform that trick.|You didn't mention what you want to pick the lock with.)/i
		(echo "Couldn't find #{pick}.";waitrt?;nextpick.call)
	elsif result.nil?
		(echo "FIX ME PLEASE! Stuck in pick3 def.";exit)
	end
}

broken_lockpick_stow = proc{
	waitrt?
	result = dothistimeout "put my #{pick} in my #{UserVars.tpick["broken_lockpick_container"]}", 4, /(You attach|You put)|(I could not find what you were referring to.|It's closed)/i
	if result =~ /(You attach|You put)/i
		nextpick.call
	elsif result =~ /(I could not find what you were referring to.|It's closed)/i and close_broken_lockpick_container == nil
		(fput "open my #{UserVars.tpick["broken_lockpick_container"]}";close_broken_lockpick_container = "yes";broken_lockpick_stow.call)
	elsif result =~ /Get what\?/i and close_broken_lockpick_container == "yes"
		(echo "Couldn't find your #{UserVars.tpick["broken_lockpick_container"]}.";exit)
	elsif result.nil?
		(echo "Error found in broken lockpick stow.";exit)
	end
}

nextpick = proc{
	before_needed_pick = needed_pick
	if needed_pick == UserVars.tpick["copper"]
		needed_pick = UserVars.tpick["steel"]
	elsif needed_pick == UserVars.tpick["steel"]
		needed_pick = UserVars.tpick["gold"]
	elsif needed_pick == UserVars.tpick["gold"]
		needed_pick = UserVars.tpick["silver"]
	elsif needed_pick == UserVars.tpick["silver"]
		needed_pick = UserVars.tpick["mithril"]
	elsif needed_pick == UserVars.tpick["mithril"]
		needed_pick = UserVars.tpick["ora"]
	elsif needed_pick == UserVars.tpick["ora"]
		needed_pick = UserVars.tpick["glaes"]
	elsif needed_pick == UserVars.tpick["glaes"]
		needed_pick = UserVars.tpick["laje"]
	elsif needed_pick == UserVars.tpick["laje"]
		needed_pick = UserVars.tpick["vultite"]
	elsif needed_pick == UserVars.tpick["vultite"]
		needed_pick = UserVars.tpick["rolaren"]
	elsif needed_pick == UserVars.tpick["rolaren"]
		needed_pick = UserVars.tpick["veniom"]
	elsif needed_pick == UserVars.tpick["veniom"]
		needed_pick = UserVars.tpick["invar"]
	elsif needed_pick == UserVars.tpick["invar"]
		needed_pick = UserVars.tpick["alum"]
	elsif needed_pick == UserVars.tpick["alum"]
		needed_pick = UserVars.tpick["golvern"]
	elsif needed_pick == UserVars.tpick["golvern"]
		needed_pick = UserVars.tpick["kelyn"]
	elsif needed_pick == UserVars.tpick["kelyn"]
		needed_pick = UserVars.tpick["vaalin"]
	elsif needed_pick == UserVars.tpick["vaalin"]
		need_403 = "yes"
		needed_pick = UserVars.tpick["vaalin"]
	end
	pick = needed_pick
	echo "Couldn't pick lock with #{before_needed_pick}. Trying #{needed_pick}."
	pick2.call
}

open_solo = proc{
	waitrt?
	cast_506.call if use_spell_506		
	total_boxes_picked += 1
	fput "open ##{current_box}" unless popping
	lootbox = GameObj.right_hand
	(dothistimeout "look in my #{lootbox}", 10, /In .*? you see|In the .*\:/) if lootbox.contents.nil?
	waitrt?
	fput "swap"
	lootbox.contents.each{|item|
		waitrt?
		if item.name !~ /urglaes fang/ && item.name !~ /doomstone/
			fput "get #{item} from ##{current_box}"
			if item.name =~ /coins/
				sleep 0.5
				waitrt?
				sleep 0.1
			end
		end
		if item.name !~ /coins/i && UserVars.tpick["log"] == "yes"
			record_item_data.call
		end
		waitrt?
		if item.name !~ /coins/i && item.name !~ /urglaes fang/ && item.name !~ /doomstone/
			if UserVars.tpick["auto_bundle_vials"] == "yes" && item.name =~ /vial/ && (GameObj.right_hand.name =~ /vial/ || GameObj.left_hand.name =~ /vial/)
				check_locksmiths_container.call
				wait_until { vials_remaining }
				start_script "sorter" if start_sorter
				if vials_remaining < 10
					if GameObj.right_hand.name =~ /vial/
						current_vial = GameObj.right_hand.id
					elsif GameObj.left_hand.name =~ /vial/
						current_vial = GameObj.left_hand.id
					end
					fput "stow ##{current_vial}"
					fput "stow ##{current_box}"
					sleep 0.2
					stow_right.call
					stow_left.call
					wait_until { checkleft == nil }
					wait_until { checkright == nil }
					fput "remove my #{UserVars.tpick["locksmiths_container"]}"
					wait_until { checkright != nil }
					fput "get ##{current_vial}"
					wait_until { checkleft != nil }
					fput "bundle"
					fput "wear my #{UserVars.tpick["locksmiths_container"]}"
					wait_until { checkright == nil }
					fput "get ##{current_box}"
					wait_until { checkright != nil }			
				end
			else
				if item.type =~ /gem/ && gem_container
					fput "put #{item} in my #{gem_container}"
				else
					fput "stow #{item}"
				end
			end
		end
	}
	do_relock_boxes.call if relock_boxes
	garbage_check.call
	if box != "none"
		stow_right.call
		stow_left.call
		sleep 0.1
	else
		stow_right.call
		stow_left.call
	end
}

garbage_check = proc{
	waitrt?
	if UserVars.tpick["trash_boxes"] == "yes"
		if checkroom =~ /table|booth/i
			if solo_or_other == "solo"
				until checkleft == nil
					waitrt?
					fput "drop ##{current_box}"
					sleep 0.1
				end
			end
			fput "clean table"
		elsif GameObj.loot.find { |loot| trash = loot if loot.name =~ trash_container }
			waitrt?
			fput "get ##{current_box}" if solo_or_other == "ground"
			fput "put ##{current_box} in #{trash}"
		else
			if solo_or_other == "solo"
				until checkleft == nil
					waitrt?
					fput "drop ##{current_box}"
					sleep 0.1
				end
			end
		end
	else
		if solo_or_other == "solo"
			until checkleft == nil
				waitrt?
				fput "drop ##{current_box}"
				sleep 0.1
			end
		end
	end
	waitrt?
}

record_item_data = proc{
		if GameObj.right_hand.type =~ /gem/i
			gem = Array.new if gem == nil
			(gem.push(GameObj.right_hand.name);gem_number[gem.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /reagent/i
			reagent = Array.new if reagent == nil
			(reagent.push(GameObj.right_hand.name);reagent_number[reagent.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /herb/i
			herb = Array.new if herb == nil
			(herb.push(GameObj.right_hand.name);herb_number[herb.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /food/i
			food = Array.new if food == nil
			(food.push(GameObj.right_hand.name);food_number[food.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /uncommon/i
			uncommon = Array.new if uncommon == nil
			(uncommon.push(GameObj.right_hand.name);uncommon_number[uncommon.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /jewelry/i
			jewelry = Array.new if jewelry == nil
			(jewelry.push(GameObj.right_hand.name);jewelry_number[jewelry.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /junk/i
			junk = Array.new if junk == nil
			(junk.push(GameObj.right_hand.name);junk_number[junk.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /lockpick/i
			lockpick = Array.new if lockpick == nil
			(lockpick.push(GameObj.right_hand.name);lockpick_number[lockpick.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /magic/i
			magic = Array.new if magic == nil
			(magic.push(GameObj.right_hand.name);magic_number[magic.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /scroll/i
			scroll = Array.new if scroll == nil
			(scroll.push(GameObj.right_hand.name);scroll_number[scroll.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /wand/i
			wand = Array.new if wand == nil
			(wand.push(GameObj.right_hand.name);wand_number[wand.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /armor/i
			armor = Array.new if armor == nil
			(armor.push(GameObj.right_hand.name);armor_number[armor.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /weapon/i
			weapon = Array.new if weapon == nil
			(weapon.push(GameObj.right_hand.name);weapon_number[weapon.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /clothing/i
			clothing = Array.new if clothing == nil
			(clothing.push(GameObj.right_hand.name);clothing_number[clothing.index(GameObj.right_hand.name)] += 1)
		else
			other = Array.new if other == nil
			(other.push(GameObj.right_hand.name);other_number[other.index(GameObj.right_hand.name)] += 1)
		end
}

open_others = proc{
	waitrt?
	fput "give ##{current_box} to #{person}"
	start_others.call
}

before_dying { if ground_loot || solo_or_other == "solo"
			wealth_after.call
			wait_until { silver_after }
			silver_gained = silver_after - silver_before
		end;
		DownstreamHook.remove("#{script.name}_check_locksmiths_container")
}
#before_dying { (fput "close my #{UserVars.tpick["wedge_container"]}" if close_wedge_sack == "yes";fput "close my #{UserVars.tpick["calipers_container"]}" if close_calipers_sack == "yes";fput "close my #{UserVars.tpick["lockpick_container"]}" if close_lockpick_sack == "yes";fput "close my #{UserVars.tpick["scale_weapon_container"]}" if close_scaleweapon_sack == "yes";fput "close my #{UserVars.tpick["broken_lockpick_container"]}" if close_broken_lockpick_container == "yes") } 
before_dying { respond "Total boxes picked: #{total_boxes_picked}" if ground_loot || solo_or_other == "solo" }
before_dying { respond "Total silvers gained: #{silver_gained}" if ground_loot || solo_or_other == "solo" }
before_dying { (gem.uniq! if gem != nil;reagent.uniq! if reagent != nil;herb.uniq! if herb != nil;food.uniq! if food != nil;uncommon.uniq! if uncommon != nil;jewelry.uniq! if jewelry != nil;junk.uniq! if junk != nil;lockpick.uniq!if lockpick != nil;magic.uniq! if magic != nil;scroll.uniq! if scroll != nil;wand.uniq! if wand != nil;armor.uniq! if armor != nil;weapon.uniq! if weapon != nil;other.uniq! if other != nil;clothing.uniq if clothing != nil) if ground_loot || solo_or_other == "solo"}
before_dying { (respond "\nGems:\n";gem.each{|item|respond "#{item} x#{gem_number[gem.index(item)]}"}) if gem != nil and (ground_loot or solo_or_other == "solo") }
before_dying { (respond "\nReagents:\n";reagent.each{|item|respond "#{item} x#{reagent_number[reagent.index(item)]}"}) if reagent != nil and (ground_loot or solo_or_other == "solo") }
before_dying { (respond "\nHerbs:\n";herb.each{|item|respond "#{item} x#{herb_number[herb.index(item)]}"}) if herb != nil and (ground_loot or solo_or_other == "solo") }
before_dying { (respond "\nFood:\n";food.each{|item|respond "#{item} x#{food_number[food.index(item)]}"}) if food != nil and (ground_loot or solo_or_other == "solo") }
before_dying { (respond "\nUncommon:\n";uncommon.each{|item|respond "#{item} x#{uncommon_number[uncommon.index(item)]}"}) if uncommon != nil and (ground_loot or solo_or_other == "solo") }
before_dying { (respond "\nJewelry:\n";jewelry.each{|item|respond "#{item} x#{jewelry_number[jewelry.index(item)]}"}) if jewelry != nil and (ground_loot or solo_or_other == "solo") }
before_dying { (respond "\nJunk:\n";junk.each{|item|respond "#{item} x#{junk_number[junk.index(item)]}"}) if junk != nil and (ground_loot or solo_or_other == "solo") }
before_dying { (respond "\nLockpicks:\n";lockpick.each{|item|respond "#{item} x#{lockpick_number[lockpick.index(item)]}"}) if lockpick != nil and (ground_loot or solo_or_other == "solo") }
before_dying { (respond "\nMagic:\n";magic.each{|item|respond "#{item} x#{magic_number[magic.index(item)]}"}) if magic != nil and (ground_loot or solo_or_other == "solo") }
before_dying { (respond "\nScrolls:\n";scroll.each{|item|respond "#{item} x#{scroll_number[scroll.index(item)]}"}) if scroll != nil and (ground_loot or solo_or_other == "solo") }
before_dying { (respond "\nWands:\n";wand.each{|item|respond "#{item} x#{wand_number[wand.index(item)]}"}) if wand != nil and (ground_loot or solo_or_other == "solo") }
before_dying { (respond "\nArmor:\n";armor.each{|item|respond "#{item} x#{armor_number[armor.index(item)]}"}) if armor != nil and (ground_loot or solo_or_other == "solo") }
before_dying { (respond "\nWeapons:\n";weapon.each{|item|respond "#{item} x#{weapon_number[weapon.index(item)]}"}) if weapon != nil and (ground_loot or solo_or_other == "solo") }
before_dying { (respond "\nClothing:\n";clothing.each{|item|respond "#{item} x#{clothing_number[clothing.index(item)]}"}) if clothing != nil and (ground_loot or solo_or_other == "solo") }
before_dying { (respond "\nOther:\n";other.each{|item|respond "#{item} x#{other_number[other.index(item)]}"}) if other != nil and (ground_loot or solo_or_other == "solo") }

gem = nil
reagent = nil
herb = nil
food = nil
uncommon = nil
jewelry = nil
junk = nil
lockpick = nil
magic = nil
scroll = nil
wand = nil
armor = nil
weapon = nil
clothing = nil
other = nil

gem_number = Array.new
reagent_number = Array.new
herb_number = Array.new
food_number = Array.new
uncommon_number = Array.new
jewelry_number = Array.new
junk_number = Array.new
lockpick_number = Array.new
magic_number = Array.new
scroll_number = Array.new
wand_number = Array.new
armor_number = Array.new
weapon_number = Array.new
clothing_number = Array.new
other_number = Array.new

wealth_before = proc {
	action = proc { |server_string|
		if server_string =~ /^\s*Name\:|^\s*Gender\:|^\s*Normal \(Bonus\)|^\s*Strength \(STR\)\:|^\s*Constitution \(CON\)\:|^\s*Dexterity \(DEX\)\:|^\s*Agility \(AGI\)\:|^\s*Discipline \(DIS\)\:|^\s*Aura \(AUR\)\:|^\s*Logic \(LOG\)\:|^\s*Intuition \(INT\)\:|^\s*Wisdom \(WIS\)\:|^\s*Influence \(INF\)\:/
			nil
		elsif server_string =~ /^\s*Mana\:\s+\-?[0-9]+\s+Silver\:\s+([0-9]+)/
			silver_before = $1.to_i
			DownstreamHook.remove("#{script.name}_wealth_before")
			nil
		else
			server_string
		end
	}
		DownstreamHook.add("#{script.name}_wealth_before", action)
		silence_me
		fput "info"
		silence_me
}

wealth_after = proc{
	action = proc { |server_string|
		if server_string =~ /^\s*Name\:|^\s*Gender\:|^\s*Normal \(Bonus\)|^\s*Strength \(STR\)\:|^\s*Constitution \(CON\)\:|^\s*Dexterity \(DEX\)\:|^\s*Agility \(AGI\)\:|^\s*Discipline \(DIS\)\:|^\s*Aura \(AUR\)\:|^\s*Logic \(LOG\)\:|^\s*Intuition \(INT\)\:|^\s*Wisdom \(WIS\)\:|^\s*Influence \(INF\)\:/
			nil
		elsif server_string =~ /^\s*Mana\:\s+\-?[0-9]+\s+Silver\:\s+([0-9]+)/
			silver_after = $1.to_i
			DownstreamHook.remove("#{script.name}_wealth_after")
			nil
		else
			server_string
		end
	}
		DownstreamHook.add("#{script.name}_wealth_after", action)
		silence_me
		put "info"
		silence_me
}

stow_right = proc{
	waitrt?
	if checkright != nil
		if GameObj.right_hand.name =~ /#{lockpick_full_name[1]}|#{lockpick_full_name[2]}|#{lockpick_full_name[3]}|#{lockpick_full_name[4]}|#{lockpick_full_name[5]}|#{lockpick_full_name[6]}|#{lockpick_full_name[7]}|#{lockpick_full_name[8]}|#{lockpick_full_name[9]}|#{lockpick_full_name[10]}|#{lockpick_full_name[11]}|#{lockpick_full_name[12]}|#{lockpick_full_name[13]}|#{lockpick_full_name[14]}|#{lockpick_full_name[15]}|#{lockpick_full_name[16]}/
			fput "put right in my #{UserVars.tpick["lockpick_container"]}"
		elsif GameObj.right_hand.name =~ /wedge/
			fput "put right in my #{UserVars.tpick["wedge_container"]}"
		elsif GameObj.right_hand.name =~ /caliper/
			fput "put right in my #{UserVars.tpick["calipers_container"]}"
		elsif GameObj.right_hand.name =~ /#{scale_trap_weapon_full_name}/
			fput "put right in my #{UserVars.tpick["scale_weapon_container"]}"
		else
			fput "stow right"
		end
	end
}

stow_left = proc{
	waitrt?
	if checkleft != nil
		if GameObj.left_hand.name =~ /#{lockpick_full_name[1]}|#{lockpick_full_name[2]}|#{lockpick_full_name[3]}|#{lockpick_full_name[4]}|#{lockpick_full_name[5]}|#{lockpick_full_name[6]}|#{lockpick_full_name[7]}|#{lockpick_full_name[8]}|#{lockpick_full_name[9]}|#{lockpick_full_name[10]}|#{lockpick_full_name[11]}|#{lockpick_full_name[12]}|#{lockpick_full_name[13]}|#{lockpick_full_name[14]}|#{lockpick_full_name[15]}|#{lockpick_full_name[16]}/
			fput "put left in my #{UserVars.tpick["lockpick_container"]}"
		elsif GameObj.left_hand.name =~ /wedge/
			fput "put left in my #{UserVars.tpick["wedge_container"]}"
		elsif GameObj.left_hand.name =~ /caliper/
			fput "put left in my #{UserVars.tpick["calipers_container"]}"
		elsif GameObj.left_hand.name =~ /#{scale_trap_weapon_full_name}/
			fput "put left in my #{UserVars.tpick["scale_weapon_container"]}"
		else
			fput "stow left"
		end
	end
}

appraise_current_pick = proc{
	fput "lmas app my #{current_pick_to_check}"
	while line = get
		if line =~ /It seems to have a (detrimental|very inaccurate) level of precision and is flimsy./
			lockpick_type = "copper"
			current_wire = $tpick_copper_wire
			current_wire_cost = $tpick_copper_wire_cost
		elsif line =~ /It seems to have an inaccurate level of precision and has below average strength./
			lockpick_type = "steel"
			current_wire = $tpick_steel_wire
			current_wire_cost = $tpick_steel_wire_cost
		elsif line =~ /It seems to have an inaccurate level of precision and is weak./
			lockpick_type = "gold"
			current_wire = $tpick_gold_wire
			current_wire_cost = $tpick_gold_wire_cost
		elsif line =~ /It seems to have a somewhat inaccurate level of precision and has below average strength./
			lockpick_type = "silver"
			current_wire = $tpick_silver_wire
			current_wire_cost = $tpick_silver_wire_cost
		elsif line =~ /It seems to have a below average level of precision and is strong./
			lockpick_type = "ora"
			current_wire = $tpick_ora_wire 
			current_wire_cost = $tpick_ora_wire_cost 
		elsif line =~ /It seems to have an unreliable level of precision and is very strong./
			lockpick_type = "mithril"
			current_wire = $tpick_mithril_wire 
			current_wire_cost = $tpick_mithril_wire_cost
		elsif line =~ /It seems to have an above average level of precision and has below average strength./
			lockpick_type = "laje"
			current_wire = $tpick_laje_wire
			current_wire_cost = $tpick_laje_wire_cost
		elsif line =~ /(It seems to have an advantageous level of precision|It seems to have a highly accurate level of precision) and is (flimsy|weak)./
			lockpick_type = "alum"
			current_wire = $tpick_alum_wire
			current_wire_cost = $tpick_alum_wire_cost
		elsif line =~ /It seems to have an above average level of precision and is weak./
			lockpick_type = "vultite"
			current_wire = $tpick_vultite_wire
			current_wire_cost = $tpick_vultite_wire_cost
		elsif line =~ /It seems to have a somewhat accurate level of precision and is strong./
			lockpick_type = "rolaren"
			current_wire = $tpick_rolaren_wire
			current_wire_cost = $tpick_rolaren_wire_cost
		elsif line =~ /It seems to have an accurate level of precision and has excellent strength./
			lockpick_type = "veniom"
			current_wire = $tpick_veniom_wire
			current_wire_cost = $tpick_veniom_wire_cost
		elsif line =~ /It seems to have an excellent level of precision and is strong./
			lockpick_type = "kelyn"
			current_wire = $tpick_kelyn_wire
			current_wire_cost = $tpick_kelyn_wire_cost
		elsif line =~ /It seems to have a highly accurate level of precision and is incredibly strong./
			lockpick_type = "invar"
			current_wire = $tpick_invar_wire
			current_wire_cost = $tpick_invar_wire_cost
		elsif line =~ /It seems to have an excellent level of precision and is astonishingly strong./
			lockpick_type = "golvern"
			current_wire = $tpick_golvern_wire
			current_wire_cost = $tpick_golvern_wire_cost
		elsif line =~ /It seems to have an incredible level of precision and is incredibly strong./
			lockpick_type = "vaalin"
			current_wire = $tpick_vaalin_wire
			current_wire_cost = $tpick_vaalin_wire_cost
		elsif line =~ /Roundtime/
			break
		end
	end
}
					
get_wire_order_numbers = proc{
	move 'out' if checkpaths 'out'
	target_room = Room.current.find_nearest(toolbenches_room_number)
	start_script 'go2', [ target_room.to_s ]
	wait_while{ running?('go2') }
	move 'go toolbench'
	fput "read sign"
	while line = get
		if line =~ /\s*(\d+)\..*copper wire\s+(\d+)/
			$tpick_copper_wire = $1
			$tpick_copper_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*brass wire\s+(\d+)/
			$tpick_brass_wire = $1
			$tpick_brass_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*steel wire\s+(\d+)/
			$tpick_steel_wire = $1
			$tpick_steel_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*gold wire\s+(\d+)/
			$tpick_gold_wire = $1
			$tpick_gold_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*silver wire\s+(\d+)/
			$tpick_silver_wire = $1
			$tpick_silver_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*ora wire\s+(\d+)/
			$tpick_ora_wire = $1
			$tpick_ora_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*mithril wire\s+(\d+)/
			$tpick_mithril_wire = $1
			$tpick_mithril_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*laje wire\s+(\d+)/
			$tpick_laje_wire = $1
			$tpick_laje_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*alum wire\s+(\d+)/
			$tpick_alum_wire = $1
			$tpick_alum_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*vultite wire\s+(\d+)/
			$tpick_vultite_wire = $1
			$tpick_vultite_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*rolaren wire\s+(\d+)/
			$tpick_rolaren_wire = $1
			$tpick_rolaren_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*veniom wire\s+(\d+)/
			$tpick_veniom_wire = $1
			$tpick_veniom_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*kelyn wire\s+(\d+)/
			$tpick_kelyn_wire = $1
			$tpick_kelyn_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*invar wire\s+(\d+)/
			$tpick_invar_wire = $1
			$tpick_invar_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*golvern wire\s+(\d+)/
			$tpick_golvern_wire = $1
			$tpick_golvern_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*vaalin wire\s+(\d+)/
			$tpick_vaalin_wire = $1
			$tpick_vaalin_wire_cost = $2
		elsif line =~ /a thin bar of vaalin/
			break
		end
	end
	move 'out' if checkpaths 'out'
}

(echo "Setup is required, type ;tpick setup.";UserVars.tpick ||= Hash.new;exit) if (UserVars.tpick.nil? or UserVars.tpick.empty?) and (script.vars[1] != 'setup')
(echo "One or more setting has not been set. Type ;tpick setup and fill out each setting.";exit) if UserVars.tpick["copper"].nil? or UserVars.tpick["copper"].empty? or UserVars.tpick["steel"].nil? or UserVars.tpick["steel"].empty? or UserVars.tpick["gold"].nil? or UserVars.tpick["gold"].empty? or UserVars.tpick["silver"].nil? or UserVars.tpick["silver"].empty? or UserVars.tpick["mithril"].nil? or UserVars.tpick["mithril"].empty? or UserVars.tpick["ora"].nil? or UserVars.tpick["ora"].empty? or UserVars.tpick["glaes"].nil? or UserVars.tpick["glaes"].empty? or UserVars.tpick["laje"].nil? or UserVars.tpick["laje"].empty? or UserVars.tpick["vultite"].nil? or UserVars.tpick["vultite"].empty? or UserVars.tpick["rolaren"].nil? or UserVars.tpick["rolaren"].empty? or UserVars.tpick["veniom"].nil? or UserVars.tpick["veniom"].empty? or UserVars.tpick["invar"].nil? or UserVars.tpick["invar"].empty? or UserVars.tpick["alum"].nil? or UserVars.tpick["alum"].empty? or UserVars.tpick["golvern"].nil? or UserVars.tpick["golvern"].empty? or UserVars.tpick["kelyn"].nil? or UserVars.tpick["kelyn"].empty? or UserVars.tpick["vaalin"].nil? or UserVars.tpick["vaalin"].empty? or 
UserVars.tpick["lockpick_container"].nil? or UserVars.tpick["lockpick_container"].empty? or UserVars.tpick["wedge_container"].nil? or UserVars.tpick["wedge_container"].empty? or UserVars.tpick["calipers_container"].nil? or UserVars.tpick["calipers_container"].empty? or UserVars.tpick["scale_trap_weapon"].nil? or UserVars.tpick["scale_trap_weapon"].empty? or UserVars.tpick["always_use_404"].nil? or UserVars.tpick["always_use_404"].empty? or UserVars.tpick["lock_roll"].nil? or UserVars.tpick["lock_roll"].empty? or UserVars.tpick["vaalin_lock_roll"].nil? or UserVars.tpick["vaalin_lock_roll"].empty? or UserVars.tpick["trick"].nil? or UserVars.tpick["trick"].empty? or UserVars.tpick["calibrate"].nil? or UserVars.tpick["calibrate"].empty? or UserVars.tpick["always_use_403"].nil? or UserVars.tpick["always_use_403"].empty? or UserVars.tpick["always_use_402"].nil? or UserVars.tpick["always_use_402"].empty? or UserVars.tpick["always_use_613"].nil? or UserVars.tpick["always_use_613"].empty? or UserVars.tpick["always_use_1006"].nil? or UserVars.tpick["always_use_1006"].empty? or UserVars.tpick["always_use_506"].nil? or UserVars.tpick["always_use_506"].empty? or UserVars.tpick["calibratecount"].nil? or UserVars.tpick["calibratecount"].empty?  or UserVars.tpick["rest_percent"].nil? or UserVars.tpick["rest_percent"].empty? or UserVars.tpick["pick_percent"].nil? or UserVars.tpick["pick_percent"].empty? or UserVars.tpick["scale_weapon_container"].nil? or UserVars.tpick["scale_weapon_container"].empty? or UserVars.tpick["broken_lockpick_container"].nil? or UserVars.tpick["broken_lockpick_container"].empty? or UserVars.tpick["always_use_407"].nil? or UserVars.tpick["always_use_407"].empty? or UserVars.tpick["log"].nil? or UserVars.tpick["log"].empty? or UserVars.tpick["trash_boxes"].nil? or UserVars.tpick["trash_boxes"].empty? or UserVars.tpick["trap_roll"].nil? or UserVars.tpick["trap_roll"].empty? or UserVars.tpick["ready"].nil? or UserVars.tpick["ready"].empty? or UserVars.tpick["cant_open_box"].nil? or UserVars.tpick["cant_open_box"].empty? or UserVars.tpick["scarab_safe"].nil? or UserVars.tpick["scarab_safe"].empty? || UserVars.tpick["number_of_times_to_check_for_traps"].empty? || UserVars.tpick["number_of_times_to_check_for_traps"].nil? and (script.vars[1] != 'setup')
(setup.call;exit) if script.vars[1] == 'setup'

if script.vars[1] =~ /buy/
	check_locksmiths_container.call
	wait_until { putty_remaining }
	wait_until { cotton_remaining }
	start_script "sorter" if start_sorter
	if putty_remaining >= 100 && cotton_remaining >= 100
		echo "You already have 100 each of putty and cotton balls."
		exit
	else
		if Wounds.lhand >= 3 || Wounds.rhand >= 3 || Wounds.larm >= 3 || Wounds.rarm >= 3 || Scars.lhand >= 3 || Scars.rhand >= 3 || Scars.larm >= 3 || Scars.rarm >= 3 
			echo "Your wounds are too great to do this task. You can't have a missing hand or arm to do this."
			exit
		else
			stow_right.call
			stow_left.call
			fill_up_locksmith_container.call
		end
	end
	exit
end

if script.vars[1] =~ /repair/ && Char.prof =~ /Rogue/
	stow_right.call
	stow_left.call
	lockpicks_to_check = [
		"#{UserVars.tpick["copper"]}",
		"#{UserVars.tpick["steel"]}",
		"#{UserVars.tpick["silver"]}",
		"#{UserVars.tpick["mithril"]}",
		"#{UserVars.tpick["ora"]}",
		"#{UserVars.tpick["laje"]}",
		"#{UserVars.tpick["vultite"]}",
		"#{UserVars.tpick["rolaren"]}",
		"#{UserVars.tpick["veniom"]}",
		"#{UserVars.tpick["invar"]}",
		"#{UserVars.tpick["alum"]}",
		"#{UserVars.tpick["golvern"]}",
		"#{UserVars.tpick["kelyn"]}",
		"#{UserVars.tpick["vaalin"]}"
	]
	lockpicks_to_check.each { |i|
		result = dothistimeout "look #{i} in my #{UserVars.tpick["broken_lockpick_container"]}", 1, /The.*appears to be broken\.|You see nothing unusual\.|I could not find what you were referring to\./
		if result =~ /The.*appears to be broken\./
			current_pick_to_check = i
			if $tpick_vaalin_wire == nil
				get_wire_order_numbers.call
			end
			fput "get my #{current_pick_to_check}"
			appraise_current_pick.call
			move 'out' if checkpaths 'out'
			start_script 'go2', [ 'bank', '--disable-confirm' ]
			wait_while{ running?('go2') }
			multifput "depo all", "withdraw #{current_wire_cost} silvers"
			target_room = Room.current.find_nearest(toolbenches_room_number)
			start_script 'go2', [ target_room.to_s ]
			wait_while{ running?('go2') }
			move 'go toolbench'
			fput "order #{current_wire}"
			fput "buy"
			result = dothistimeout "lmas repair my #{current_pick_to_check}", 2, /cooling rapidly to form a tight bond|but the broken tip refuses to work free/
			if result =~ /cooling rapidly to form a tight bond/
				waitrt?
				fput "put my #{current_pick_to_check} in my #{UserVars.tpick["lockpick_container"]}"
			elsif result =~ /but the broken tip refuses to work free/
				echo "This lockpick cannot be repaired."
				fput "stow my #{current_pick_to_check}"
			elsif result.nil?
				echo "Didn't recognize any game lines."
				exit
			end
		elsif result =~ /You see nothing unusual\.|I could not find what you were referring to\./
			nil
		elsif result.nil?
			nil
		end
	}
	move 'out' if checkpaths 'out'
	exit
elsif script.vars[1] =~ /repair/ && Char.prof !~ /Rogue/
	echo "Only rogues can repair lockpicks."
	exit
end

if UserVars.tpick["locksmiths_container"] != "nil" || UserVars.tpick["locksmiths_container"] == nil
	check_locksmiths_container.call
	wait_until { putty_remaining }
	wait_until { cotton_remaining }
	wait_until { vials_remaining }
	echo "Putty remaining: #{putty_remaining}"
	echo "Cotton balls remaining: #{cotton_remaining}"
	echo "Vials of acid remaining: #{vials_remaining}"
	start_script "sorter" if start_sorter
end

if Char.prof =~ /Rogue/
	can_use_calipers = true
	if (UserVars.tpick["trick"] == "spin" or UserVars.tpick["trick"] == "twist" or UserVars.tpick["trick"] == "turn" or UserVars.tpick["trick"] == "twirl" or UserVars.tpick["trick"] == "toss" or UserVars.tpick["trick"] == "bend" or UserVars.tpick["trick"] == "flip")
		do_trick = "lmas ptrick #{UserVars.tpick["trick"]}"
	elsif UserVars.tpick["trick"] == "pick"
		do_trick = "pick"
	else
		(echo "Wrong value for TRICK in settings. Type ;tpick setup and enter spin, twist, turn, twirl, toss, bend, flip or pick for the TRICK setting.";exit)
	end
else
	can_use_calipers = nil
	UserVars.tpick["calibrate"] = "no"
	do_trick = "pick"
end

if Char.prof !~ /Rogue|Bard/
	always_use_vaalin = true
end

stow_right.call
stow_left.call
calibrate_count = 0

if Spell[205].known? && UserVars.tpick["always_use_205"] == "yes"
	use_spell_205 = true
end

if Spell[402].known? && UserVars.tpick["always_use_402"] == "yes"
	use_spell_402 = true
end

if Spell[403].known? && UserVars.tpick["always_use_403"] == "yes"
	use_spell_403 = true
end

if Spell[404].known? && UserVars.tpick["always_use_404"] == "yes"
	use_spell_404 = true
end

if Spell[506].known? && UserVars.tpick["always_use_506"] == "yes"
	use_spell_506 = true
end

if Spell[613].known? && UserVars.tpick["always_use_613"] == "yes"
	use_spell_613 = true
end

if Spell[704].known? && UserVars.tpick["always_use_704"] == "yes"
	use_spell_704 = true
end

if Spell[1006].known? && UserVars.tpick["always_use_1006"] == "yes"
	use_spell_1006 = true
end

if (script.vars[1] == "loot" || script.vars[2] == "loot" || script.vars[3] == "loot" || script.vars[4] == "loot" || script.vars[5] == "loot" || script.vars[6] == "loot" || script.vars[7] == "loot" || script.vars[8] == "loot" || script.vars[9] == "loot" || script.vars[10] == "loot")
	ground_loot = true
	wealth_before.call
	wait_until { silver_before }
end

if (script.vars[1] == "v" || script.vars[2] == "v" || script.vars[3] == "v" || script.vars[4] == "v" || script.vars[5] == "v" || script.vars[6] == "v" || script.vars[7] == "v" || script.vars[8] == "v" || script.vars[9] == "v" || script.vars[10] == "v")
	always_use_vaalin = true
end

if (script.vars[1] == "relock" || script.vars[2] == "relock" || script.vars[3] == "relock" || script.vars[4] == "relock" || script.vars[5] == "relock" || script.vars[6] == "relock" || script.vars[7] == "relock" || script.vars[8] == "relock" || script.vars[9] == "relock" || script.vars[10] == "relock")
	relock_boxes = true
end

if (script.vars[1] == "pop" || script.vars[2] == "pop" || script.vars[3] == "pop" || script.vars[4] == "pop" || script.vars[5] == "pop" || script.vars[6] == "pop" || script.vars[7] == "pop" || script.vars[8] == "pop" || script.vars[9] == "pop" || script.vars[10] == "pop")
	popping = true
end

if popping && !Spell[416].known?
	echo "This feature requires the knowledge of Piercing Gaze (416)."
	exit
end

if popping && (UserVars.tpick["always_use_704"].nil? || UserVars.tpick["number_of_416_casts"].nil? || UserVars.tpick["only_disarm_safe"].nil? || UserVars.tpick["always_use_704"].empty? || UserVars.tpick["number_of_416_casts"].empty? || UserVars.tpick["only_disarm_safe"].empty?)
	echo "This feature requires all settings in the Popping tab in setup to be filled out before using."
	exit
end

cast_205.call if use_spell_205

if UserVars.tpick["gem_container"] == nil || UserVars.tpick["gem_container"] == "nil"
	nil
else
	gem_container = UserVars.tpick["gem_container"]
end

if (script.vars[1] == "ground" || script.vars[2] == "ground" || script.vars[3] == "ground" || script.vars[4] == "ground" || script.vars[5] == "ground" || script.vars[6] == "ground" || script.vars[7] == "ground" || script.vars[8] == "ground" || script.vars[9] == "ground" || script.vars[10] == "ground")
	solo_or_other = "ground"
	if (UserVars.tpick["calibrate"] == "yes") && (always_use_vaalin == nil) && (popping == nil) && (can_use_calipers)
		calibrate.call
	end
	start_ground.call
elsif (script.vars[1] == "other" || script.vars[2] == "other" || script.vars[3] == "other" || script.vars[4] == "other" || script.vars[5] == "other" || script.vars[6] == "other" || script.vars[7] == "other" || script.vars[8] == "other" || script.vars[9] == "other" || script.vars[10] == "other")
	if popping
		echo "Popping feature does not work when popping other people's boxes."
		exit
	end
	solo_or_other = "other"
	fput "'#{UserVars.tpick["ready"]}" if UserVars.tpick["ready"] != "nil"
	start_others.call
else
	solo_or_other = "solo"
	wealth_before.call
	wait_until { silver_before }
	check_for_command = "inv full"
	check_for_boxes.call
	wait_until { $tpick_boxes_checked }
	if popping
		pop_start.call
	else
		if (UserVars.tpick["calibrate"] == "yes") && (always_use_vaalin == nil) && (can_use_calipers)
			calibrate.call
		end
		start_solo.call
	end
end